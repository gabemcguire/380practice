{
  "sections": [
    {
      "id": "entity-relationship-diagrams",
      "type": "topic",
      "title": "Entity-Relationship Diagrams I",
      "difficulty": "Easy",
      "questions": [
        {
          "id": "erd-q1",
          "question": "What is the purpose of the Entity-Relationship (E/R) Model?",
          "options": [
            "To describe a system for designing a web page",
            "To describe the database and capture constraints",
            "To build front-end interfaces",
            "To represent server connections"
          ],
          "answer": "To describe the database and capture constraints",
          "explanation": "The E/R model is used to describe the system we want to represent in a database, including its constraints."
        },
        {
          "id": "erd-q2",
          "question": "What shape is used to represent an Entity Set in an ER Diagram?",
          "options": ["Diamond", "Rectangle", "Oval", "Circle"],
          "answer": "Rectangle",
          "explanation": "In an ER diagram, an entity set is represented by a rectangle."
        },
        {
          "id": "erd-q3",
          "question": "Which shape is used to represent attributes in an Entity-Relationship Diagram?",
          "options": ["Diamond", "Oval", "Rectangle", "Triangle"],
          "answer": "Oval",
          "explanation": "In an ER diagram, attributes are represented by ovals connected to their respective entities."
        },
        {
          "id": "erd-q4",
          "question": "What does a diamond represent in an ER diagram?",
          "options": ["Entity", "Attribute", "Relationship", "Primary Key"],
          "answer": "Relationship",
          "explanation": "In an ER diagram, a diamond is used to represent relationships between entities."
        },
        {
          "id": "erd-q5",
          "question": "Which of the following is an example of an Entity Set?",
          "options": ["Player", "name", "position", "Team"],
          "answer": "Player",
          "explanation": "An entity set is a collection of similar entities, such as 'Player' in a sports system."
        },
        {
          "id": "erd-q6",
          "question": "What is an Entity Set?",
          "options": [
            "A collection of similar entities",
            "A collection of relationships between entities",
            "A unique identifier for an entity",
            "A set of attributes"
          ],
          "answer": "A collection of similar entities",
          "explanation": "An entity set is a collection of similar entities, like all 'Players' in a sports team."
        },
        {
          "id": "erd-q7",
          "question": "In an ER Diagram, what is represented by a relationship?",
          "options": [
            "An attribute connecting two entity sets",
            "A diamond representing the connection between two or more entity sets",
            "A connection between an attribute and an entity set",
            "A unique identifier for each entity"
          ],
          "answer": "A diamond representing the connection between two or more entity sets",
          "explanation": "A relationship is represented by a diamond connecting two or more entity sets in an ER diagram."
        },
        {
          "id": "erd-q8",
          "question": "What type of attribute cannot be used in an ER diagram?",
          "options": [
            "String",
            "Integer",
            "List or collection",
            "Date"
          ],
          "answer": "List or collection",
          "explanation": "Attributes in ER diagrams must be simple, meaning they cannot be lists, collections, or composite structures."
        },
        {
          "id": "erd-q9",
          "question": "What is the value of an entity set?",
          "options": [
            "The attributes it contains",
            "The relationships it has",
            "The set of entities that belong to it",
            "Its primary key"
          ],
          "answer": "The set of entities that belong to it",
          "explanation": "The value of an entity set is the collection of entities that belong to that set."
        },
        {
          "id": "erd-q10",
          "question": "What is a primary key in the context of an ER diagram?",
          "options": [
            "An attribute that uniquely identifies each entity in an entity set",
            "An attribute that represents a relationship between two entities",
            "A set of entities that are related to each other",
            "A graphical symbol used in ER diagrams"
          ],
          "answer": "An attribute that uniquely identifies each entity in an entity set",
          "explanation": "A primary key is an attribute (or set of attributes) that uniquely identifies each entity in an entity set."
        }
      ]
    },
    {
      "id": "sql-basics-I",
      "type": "topic",
      "title": "SQL Basics I",
      "difficulty": "Easy",
      "questions": [
        {
          "id": "sqlb1-q1",
          "question": "What does SQL stand for?",
          "options": [
            "Structured Query Language",
            "Simple Question Language",
            "Structured Question Logic",
            "System Query Language"
          ],
          "answer": "Structured Query Language",
          "explanation": "SQL stands for Structured Query Language, which is used for managing and manipulating relational databases."
        },
        {
          "id": "sqlb1-q2",
          "question": "Write a SQL query to select all columns from the 'users' table.",
          "initialData": [
            "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT);",
            "INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');",
            "INSERT INTO users (name, email) VALUES ('Jane Smith', 'jane@example.com');"
          ],
          "expectedResult": "SELECT * FROM users;",
          "explanation": "The query 'SELECT * FROM users;' selects all columns and rows from the 'users' table."
        },
        {
          "id": "sqlb1-q3",
          "question": "Suppose you have two tables, 'users' and 'orders'. The 'users' table has columns 'id', 'name', and 'email'. The 'orders' table has columns 'id', 'user_id', 'product', and 'order_date'. Write a SQL query to list all users along with the number of orders they have placed. Make sure you have columns id, name, and email in that order. The list should include users who have not placed any orders.",
          "initialData": [
            "CREATE TABLE users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT UNIQUE NOT NULL ); CREATE TABLE orders ( id INTEGER PRIMARY KEY, user_id INTEGER, product TEXT NOT NULL, order_date DATE NOT NULL, FOREIGN KEY(user_id) REFERENCES users(id) ); INSERT INTO users (id, name, email) VALUES (1, 'John Doe', 'john@example.com'), (2, 'Jane Smith', 'jane@sample.com'), (3, 'Alice Johnson', 'alice@example.com'), (4, 'Bob Brown', 'bob@another.com'); INSERT INTO orders (id, user_id, product, order_date) VALUES (1, 1, 'Laptop', '2023-01-15'), (2, 1, 'Mouse', '2023-02-20'), (3, 3, 'Keyboard', '2023-03-10');"
          ],
          "expectedResult": "SELECT u.id, u.name, u.email, COUNT(o.id) AS order_count FROM users u LEFT JOIN orders o ON u.id = o.user_id GROUP BY u.id, u.name, u.email;",
          "explanation": "This query performs a LEFT JOIN between the 'users' and 'orders' tables to ensure all users are included, even those without any orders. It then groups the results by user ID and name, counting the number of orders each user has placed using the COUNT() function. Users with no orders will have an order_count of 0."
        },
        {
          "id": "sqlb1-q4",
          "question": "Retrieve all records from the 'users' table.",
          "initialData": [
            "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);",
            "INSERT INTO users (name) VALUES ('Alice'), ('Bob');"
          ],
          "expectedResult": "SELECT * FROM users;"
        }
      ]
    },
    {
      "id": "sql-basics-II",
      "type": "topic",
      "title": "SQL Basics II",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-basics-1",
          "question": "Write a SQL query to return the total number of unique book titles in the 'library' table.",
          "initialData": [
            "CREATE TABLE library (book_id INTEGER PRIMARY KEY, title TEXT, author TEXT, genre TEXT);",
            "INSERT INTO library (title, author, genre) VALUES ('The Great Gatsby', 'F. Scott Fitzgerald', 'Fiction'), ('Moby Dick', 'Herman Melville', 'Fiction'), ('The Great Gatsby', 'F. Scott Fitzgerald', 'Fiction');"
          ],
          "expectedResult": "SELECT COUNT(DISTINCT title) FROM library;",
          "explanation": "This query counts the number of distinct book titles in the 'library' table."
        },
        {
          "id": "sql-basics-2",
          "question": "Write a SQL query to return all employees from the 'employees' table, ordered by salary from highest to lowest.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, salary DECIMAL);",
            "INSERT INTO employees (name, salary) VALUES ('John', 55000), ('Jane', 72000), ('Emily', 60000);"
          ],
          "expectedResult": "SELECT * FROM employees ORDER BY salary DESC;",
          "explanation": "This query selects all columns from the 'employees' table and orders the results by salary in descending order."
        },
        {
          "id": "sql-basics-3",
          "question": "Write a SQL query to create a table called 'students' with columns: student_id (integer, primary key), name (text), age (integer), and major (text).",
          "initialData": [],
          "expectedResult": "CREATE TABLE students (student_id INTEGER PRIMARY KEY, name TEXT, age INTEGER, major TEXT);",
          "explanation": "This query creates a 'students' table with columns for student ID, name, age, and major, defining 'student_id' as the primary key."
        },
        {
          "id": "sql-basics-4",
          "question": "Write a SQL query to return the names and ages of all students who are majoring in 'Computer Science'.",
          "initialData": [
            "CREATE TABLE students (student_id INTEGER PRIMARY KEY, name TEXT, age INTEGER, major TEXT);",
            "INSERT INTO students (name, age, major) VALUES ('Alice', 20, 'Computer Science'), ('Bob', 21, 'Mathematics'), ('Charlie', 22, 'Computer Science');"
          ],
          "expectedResult": "SELECT name, age FROM students WHERE major = 'Computer Science';",
          "explanation": "This query retrieves the 'name' and 'age' columns for students majoring in 'Computer Science'."
        },
        {
          "id": "sql-basics-5",
          "question": "What is the difference between `ORDER BY` and `GROUP BY` in SQL?",
          "options": [
            "`ORDER BY` sorts the result set, while `GROUP BY` groups rows with the same values in specified columns.",
            "`ORDER BY` groups rows with the same values, while `GROUP BY` sorts them.",
            "`ORDER BY` filters out duplicate rows, while `GROUP BY` displays all rows.",
            "`ORDER BY` is used only for text fields, while `GROUP BY` is used for numeric fields."
          ],
          "answer": "`ORDER BY` sorts the result set, while `GROUP BY` groups rows with the same values in specified columns.",
          "explanation": "`ORDER BY` is used to sort the result set, whereas `GROUP BY` groups rows that have the same values in specified columns, typically used with aggregate functions."
        },
        {
          "id": "sql-basics-6",
          "question": "Write a SQL query that groups students by their 'class' and counts the number of students in each class.",
          "initialData": [
            "CREATE TABLE students (id INTEGER PRIMARY KEY, name TEXT, class TEXT);",
            "INSERT INTO students (name, class) VALUES ('John Doe', 'CSE380'), ('Jane Smith', 'CSE380'), ('Bob Brown', 'CSE250');"
          ],
          "expectedResult": "SELECT class, COUNT(*) FROM students GROUP BY class;",
          "explanation": "This query groups students by their 'class' and counts the number of students in each group."
        },
        {
          "id": "sql-basics-7",
          "question": "What is the purpose of the `HAVING` clause in SQL?",
          "options": [
            "It filters the result set after grouping.",
            "It filters the result set before grouping.",
            "It sorts the result set based on aggregates.",
            "It combines two result sets into one."
          ],
          "answer": "It filters the result set after grouping.",
          "explanation": "The `HAVING` clause is used to filter groups of rows after the `GROUP BY` clause has been applied."
        }
      ]
    },
    
    {
      "id": "sql-joins",
      "type": "topic",
      "title": "SQL Joins",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-joins-1",
          "question": "What type of join is used to return all records from both tables, with matching records from both sides where available?",
          "options": [
            "INNER JOIN",
            "LEFT JOIN",
            "RIGHT JOIN",
            "FULL OUTER JOIN"
          ],
          "answer": "FULL OUTER JOIN",
          "explanation": "A FULL OUTER JOIN returns all rows from both tables, matching rows where possible, and filling in NULLs where there are no matches."
        },
        {
          "id": "sql-joins-2",
          "question": "Write a SQL query to return the names of students and the courses they are enrolled in, showing students even if they are not enrolled in any course. Use the 'students' and 'enrollments' tables.",
          "initialData": [
            "CREATE TABLE students (student_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE enrollments (student_id INTEGER, course_name TEXT);",
            "INSERT INTO students (student_id, name) VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');",
            "INSERT INTO enrollments (student_id, course_name) VALUES (1, 'Math'), (1, 'Science'), (3, 'History');"
          ],
          "expectedResult": "SELECT students.name, enrollments.course_name FROM students LEFT JOIN enrollments ON students.student_id = enrollments.student_id;",
          "explanation": "This query uses a LEFT JOIN to include all students, even those not enrolled in any courses. It matches students with their courses based on the 'student_id'."
        },
        {
          "id": "sql-joins-3",
          "question": "Write a SQL query to return the names of employees and their department names, but only show employees who are assigned to a department. Use the 'employees' and 'departments' tables.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, department_id INTEGER);",
            "CREATE TABLE departments (department_id INTEGER PRIMARY KEY, department_name TEXT);",
            "INSERT INTO employees (employee_id, name, department_id) VALUES (1, 'John', 101), (2, 'Jane', 102), (3, 'Emily', NULL);",
            "INSERT INTO departments (department_id, department_name) VALUES (101, 'HR'), (102, 'Engineering');"
          ],
          "expectedResult": "SELECT employees.name, departments.department_name FROM employees INNER JOIN departments ON employees.department_id = departments.department_id;",
          "explanation": "This query uses an INNER JOIN to return only employees who are assigned to a department, matching records on 'department_id'."
        },
        {
          "id": "sql-joins-4",
          "question": "Write a SQL query to return the names of all projects and the names of their assigned managers, even if the project has no manager. Use the 'projects' and 'managers' tables.",
          "initialData": [
            "CREATE TABLE projects (project_id INTEGER PRIMARY KEY, project_name TEXT, manager_id INTEGER);",
            "CREATE TABLE managers (manager_id INTEGER PRIMARY KEY, name TEXT);",
            "INSERT INTO projects (project_id, project_name, manager_id) VALUES (1, 'Project A', 1), (2, 'Project B', NULL);",
            "INSERT INTO managers (manager_id, name) VALUES (1, 'Michael');"
          ],
          "expectedResult": "SELECT projects.project_name, managers.name FROM projects LEFT JOIN managers ON projects.manager_id = managers.manager_id;",
          "explanation": "This query uses a LEFT JOIN to return all projects, including those without an assigned manager. Projects with no manager will have NULL for the manager name."
        }
      ]
    },
    {
      "id": "sql-joins-ii",
      "type": "topic",
      "title": "SQL Joins II",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-joins-ii-5",
          "question": "Write a SQL query to return the count of students enrolled in each course. Show the course name even if no students are enrolled. Use the 'courses' and 'enrollments' tables.",
          "initialData": [
            "CREATE TABLE courses (course_id INTEGER PRIMARY KEY, course_name TEXT);",
            "CREATE TABLE enrollments (student_id INTEGER, course_id INTEGER);",
            "INSERT INTO courses (course_id, course_name) VALUES (1, 'Math'), (2, 'Science'), (3, 'History');",
            "INSERT INTO enrollments (student_id, course_id) VALUES (1, 1), (2, 1), (3, 2);"
          ],
          "expectedResult": "SELECT courses.course_name, COUNT(enrollments.student_id) AS student_count FROM courses LEFT JOIN enrollments ON courses.course_id = enrollments.course_id GROUP BY courses.course_name;",
          "explanation": "This query uses a LEFT JOIN to show all courses, even those without students, and groups the result by course name to count the number of students enrolled in each course."
        },
        {
          "id": "sql-joins-ii-6",
          "question": "Write a SQL query to return the names of employees and their department names, ordered by department name. Use the 'employees' and 'departments' tables.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, department_id INTEGER);",
            "CREATE TABLE departments (department_id INTEGER PRIMARY KEY, department_name TEXT);",
            "INSERT INTO employees (employee_id, name, department_id) VALUES (1, 'John', 101), (2, 'Jane', 102), (3, 'Emily', 101);",
            "INSERT INTO departments (department_id, department_name) VALUES (101, 'HR'), (102, 'Engineering');"
          ],
          "expectedResult": "SELECT employees.name, departments.department_name FROM employees INNER JOIN departments ON employees.department_id = departments.department_id ORDER BY departments.department_name;",
          "explanation": "This query uses an INNER JOIN to return employees assigned to departments and orders the result by the department name."
        },
        {
          "id": "sql-joins-ii-7",
          "question": "Write a SQL query to return the names of all customers whose names contain the letter 'a', along with their order count. Use the 'customers' and 'orders' tables.",
          "initialData": [
            "CREATE TABLE customers (customer_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE orders (order_id INTEGER PRIMARY KEY, customer_id INTEGER);",
            "INSERT INTO customers (customer_id, name) VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');",
            "INSERT INTO orders (order_id, customer_id) VALUES (1, 1), (2, 1), (3, 3);"
          ],
          "expectedResult": "SELECT customers.name, COUNT(orders.order_id) AS order_count FROM customers LEFT JOIN orders ON customers.customer_id = orders.customer_id WHERE customers.name LIKE '%a%' GROUP BY customers.name;",
          "explanation": "This query uses a LEFT JOIN to return customers with their order count, including those with no orders. It filters the customers whose names contain the letter 'a' using the LIKE clause and groups the results by customer name."
        }
      ]
    },
    
    {
      "id": "sql-joins-iii",
      "type": "topic",
      "title": "SQL Joins III",
      "difficulty": "Hard",
      "questions": [
        {
          "id": "sql-joins-iii-1",
          "question": "Write a SQL query to return the names of employees, their department names, and their managers' names. Return all employees, including those without a department or manager. Use the 'employees', 'departments', and 'managers' tables.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, department_id INTEGER, manager_id INTEGER);",
            "CREATE TABLE departments (department_id INTEGER PRIMARY KEY, department_name TEXT);",
            "CREATE TABLE managers (manager_id INTEGER PRIMARY KEY, name TEXT);",
            "INSERT INTO employees (employee_id, name, department_id, manager_id) VALUES (1, 'John', 101, 1), (2, 'Jane', 102, 2), (3, 'Emily', NULL, 2);",
            "INSERT INTO departments (department_id, department_name) VALUES (101, 'HR'), (102, 'Engineering');",
            "INSERT INTO managers (manager_id, name) VALUES (1, 'Michael'), (2, 'Sarah');"
          ],
          "expectedResult": "SELECT employees.name AS employee_name, departments.department_name, managers.name AS manager_name FROM employees LEFT JOIN departments ON employees.department_id = departments.department_id LEFT JOIN managers ON employees.manager_id = managers.manager_id;",
          "explanation": "This query uses two LEFT JOINs to return all employees, including those without a department or manager, and matches them with their respective department and manager."
        },
        {
          "id": "sql-joins-iii-2",
          "question": "Write a SQL query to return the names of all products and the total quantity ordered for each product, including products that have never been ordered. Use the 'products' and 'orders' tables.",
          "initialData": [
            "CREATE TABLE products (product_id INTEGER PRIMARY KEY, product_name TEXT);",
            "CREATE TABLE orders (order_id INTEGER PRIMARY KEY, product_id INTEGER, quantity INTEGER);",
            "INSERT INTO products (product_id, product_name) VALUES (1, 'Laptop'), (2, 'Mouse'), (3, 'Keyboard');",
            "INSERT INTO orders (order_id, product_id, quantity) VALUES (1, 1, 10), (2, 1, 5), (3, 2, 20);"
          ],
          "expectedResult": "SELECT products.product_name, COALESCE(SUM(orders.quantity), 0) AS total_quantity FROM products LEFT JOIN orders ON products.product_id = orders.product_id GROUP BY products.product_name;",
          "explanation": "This query uses a LEFT JOIN to include all products, even those with no orders. The COALESCE function ensures that products without orders will have a total quantity of 0."
        },
        {
          "id": "sql-joins-iii-3",
          "question": "Write a SQL query to return the names of customers and the total amount they spent, including customers who have not placed any orders. Use the 'customers', 'orders', and 'order_items' tables.",
          "initialData": [
            "CREATE TABLE customers (customer_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE orders (order_id INTEGER PRIMARY KEY, customer_id INTEGER);",
            "CREATE TABLE order_items (order_item_id INTEGER PRIMARY KEY, order_id INTEGER, price DECIMAL);",
            "INSERT INTO customers (customer_id, name) VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');",
            "INSERT INTO orders (order_id, customer_id) VALUES (1, 1), (2, 1), (3, 3);",
            "INSERT INTO order_items (order_item_id, order_id, price) VALUES (1, 1, 50.00), (2, 1, 30.00), (3, 3, 70.00);"
          ],
          "expectedResult": "SELECT customers.name, COALESCE(SUM(order_items.price), 0) AS total_spent FROM customers LEFT JOIN orders ON customers.customer_id = orders.customer_id LEFT JOIN order_items ON orders.order_id = order_items.order_id GROUP BY customers.name;",
          "explanation": "This query uses LEFT JOINs to include customers who have not placed any orders and calculates the total amount spent for each customer. The COALESCE function ensures customers with no orders show a total of 0."
        },
        {
          "id": "sql-joins-iii-4",
          "question": "Write a SQL query to return the names of employees and their projects, including employees not assigned to any projects. Use the 'employees' and 'projects' tables.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE projects (project_id INTEGER PRIMARY KEY, project_name TEXT, employee_id INTEGER);",
            "INSERT INTO employees (employee_id, name) VALUES (1, 'John'), (2, 'Jane'), (3, 'Emily');",
            "INSERT INTO projects (project_id, project_name, employee_id) VALUES (1, 'Project A', 1), (2, 'Project B', NULL);"
          ],
          "expectedResult": "SELECT employees.name AS employee_name, projects.project_name FROM employees LEFT JOIN projects ON employees.employee_id = projects.employee_id;",
          "explanation": "This query uses a LEFT JOIN to return all employees, including those without any projects, and matches them with their respective project if assigned."
        },
        {
          "id": "sql-joins-iii-5",
          "question": "Write a SQL query to return all departments and the total number of employees in each department, including departments with no employees. Use the 'departments' and 'employees' tables.",
          "initialData": [
            "CREATE TABLE departments (department_id INTEGER PRIMARY KEY, department_name TEXT);",
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, department_id INTEGER);",
            "INSERT INTO departments (department_id, department_name) VALUES (101, 'HR'), (102, 'Engineering'), (103, 'Finance');",
            "INSERT INTO employees (employee_id, department_id) VALUES (1, 101), (2, 102), (3, 101);"
          ],
          "expectedResult": "SELECT departments.department_name, COUNT(employees.employee_id) AS employee_count FROM departments LEFT JOIN employees ON departments.department_id = employees.department_id GROUP BY departments.department_name;",
          "explanation": "This query uses a LEFT JOIN to include all departments, even those with no employees. The COUNT function ensures departments without employees will return a count of 0."
        }
      ]
    },
    {
      "id": "json-web-tokens",
      "type": "topic",
      "title": "JSON Web Tokens (JWTs)",
      "difficulty": "Easy",
      "questions": [
        {
          "id": "jwt-1",
          "question": "What is a JSON Web Token (JWT) used for?",
          "options": [
            "To encrypt data",
            "To represent a set of permissions for a user",
            "To securely transmit information between parties as a JSON object",
            "To store information in a database"
          ],
          "answer": "To securely transmit information between parties as a JSON object",
          "explanation": "JWTs are used to securely transmit information between parties as a JSON object, typically for authentication and authorization."
        },
        {
          "id": "jwt-2",
          "question": "What are the three parts of a JWT?",
          "options": [
            "Header, Payload, Signature",
            "Header, Body, Footer",
            "Session, Token, Payload",
            "Request, Response, Signature"
          ],
          "answer": "Header, Payload, Signature",
          "explanation": "A JWT consists of three parts: the header, which defines the type of token and algorithm; the payload, which contains the claims; and the signature, which verifies the token's integrity."
        },
        {
          "id": "jwt-3",
          "question": "Which of the following is NOT typically included in the JWT header?",
          "options": [
            "The algorithm used",
            "The token type",
            "The user's password",
            "The key ID (kid)"
          ],
          "answer": "The user's password",
          "explanation": "The JWT header usually includes the algorithm and token type, but sensitive data like passwords are not included."
        },
        {
          "id": "jwt-4",
          "question": "How is a JWT typically encoded?",
          "options": [
            "Base64-encoded",
            "Hexadecimal-encoded",
            "Encrypted using RSA",
            "ASCII-encoded"
          ],
          "answer": "Base64-encoded",
          "explanation": "JWTs are Base64-encoded to ensure that the token can be easily transmitted over HTTP, which requires URL-safe characters."
        },
        {
          "id": "jwt-5",
          "question": "What is the purpose of the signature in a JWT?",
          "options": [
            "To encrypt the payload",
            "To verify that the token has not been tampered with",
            "To compress the token",
            "To sign the user out"
          ],
          "answer": "To verify that the token has not been tampered with",
          "explanation": "The signature ensures the integrity of the JWT by verifying that the token has not been altered after it was issued."
        },
        {
          "id": "jwt-6",
          "question": "What is the middle part of a JWT?",
          "options": [
            "The base 64 header",
            "The signature",
            "The base 64 payload",
            "The base 64 signature"
          ],
          "answer": "The base 64 payload",
          "explanation": "The middle part of the JWT is the Base64-encoded payload."
        }
      ]
    },
    {
      "id": "json-web-tokens-advanced",
      "type": "topic",
      "title": "JSON Web Tokens (JWTs) - Advanced",
      "difficulty": "Hard",
      "questions": [
        {
          "id": "jwt-advanced-1",
          "question": "What algorithm is used in a JWT with the header specifying 'alg': 'HS256'?",
          "options": [
            "HMAC using SHA-256",
            "RSA using SHA-256",
            "Elliptic Curve using SHA-256",
            "MD5 with HMAC"
          ],
          "answer": "HMAC using SHA-256",
          "explanation": "HS256 specifies the use of HMAC with SHA-256 to create the signature in the JWT, combining the secret key with the hash algorithm."
        },
        {
          "id": "jwt-advanced-2",
          "question": "What vulnerability could arise if a JWT token's algorithm is changed from RS256 to none?",
          "options": [
            "The token can be altered without needing to resign it",
            "The payload becomes encrypted",
            "The token becomes invalid",
            "The signature becomes more secure"
          ],
          "answer": "The token can be altered without needing to resign it",
          "explanation": "If the algorithm is set to 'none,' the token's signature is effectively disabled, allowing attackers to modify the payload without needing to re-sign the token."
        },
        {
          "id": "jwt-advanced-3",
          "question": "Which of the following is a best practice for securing JWTs?",
          "options": [
            "Storing JWTs in local storage",
            "Storing JWTs in cookies with the 'HttpOnly' and 'Secure' flags",
            "Encoding the payload using Base64",
            "Using 'none' as the algorithm for quicker verification"
          ],
          "answer": "Storing JWTs in cookies with the 'HttpOnly' and 'Secure' flags",
          "explanation": "JWTs should be stored in secure cookies with 'HttpOnly' to prevent JavaScript access and 'Secure' to ensure they're transmitted over HTTPS only."
        },
        {
          "id": "jwt-advanced-4",
          "question": "What is the primary difference between symmetric and asymmetric encryption in the context of JWTs?",
          "options": [
            "Symmetric encryption uses one key, while asymmetric encryption uses a public/private key pair",
            "Symmetric encryption is faster but less secure than asymmetric encryption",
            "Symmetric encryption always requires a password, while asymmetric encryption does not",
            "Symmetric encryption is used in JWT signatures, while asymmetric encryption is not"
          ],
          "answer": "Symmetric encryption uses one key, while asymmetric encryption uses a public/private key pair",
          "explanation": "In JWTs, symmetric encryption (e.g., HS256) uses a single secret key for both signing and verifying, while asymmetric encryption (e.g., RS256) uses a public/private key pair for signing and verification."
        },
        {
          "id": "jwt-advanced-5",
          "question": "Which claim is used in JWTs to define an expiration time for the token?",
          "options": [
            "iat",
            "nbf",
            "exp",
            "sub"
          ],
          "answer": "exp",
          "explanation": "The 'exp' (expiration) claim is used to define the time at which the JWT will expire. After this time, the token is no longer valid."
        },
        {
          "id": "jwt-advanced-6",
          "question": "What potential security risk exists if the 'exp' claim is omitted from a JWT?",
          "options": [
            "The token will never expire and can be used indefinitely",
            "The token will automatically expire after 24 hours",
            "The token becomes invalid immediately",
            "The token can only be used once"
          ],
          "answer": "The token will never expire and can be used indefinitely",
          "explanation": "Without the 'exp' claim, the token doesn't have an expiration time, meaning it could be reused indefinitely if it is not invalidated by other means."
        }
      ]
    },
    {
      "id": "sql-create-table",
      "type": "topic",
      "title": "SQL CREATE TABLE I",
      "difficulty": "Easy",
      "questions": [
        {
          "id": "sql-create-1",
          "question": "What is the basic syntax for creating a table in SQL?",
          "options": [
            "CREATE DATABASE table_name (column_name data_type);",
            "INSERT INTO table_name (column_name data_type);",
            "CREATE TABLE table_name (column_name data_type);",
            "SELECT * FROM table_name;"
          ],
          "answer": "CREATE TABLE table_name (column_name data_type);",
          "explanation": "The basic syntax for creating a table in SQL is 'CREATE TABLE table_name (column_name data_type);'."
        },
        {
          "id": "sql-create-2",
          "question": "Write a `CREATE TABLE` statement to create a 'courses' table with the following columns: 'id' (integer primary key), 'course_name' (text), 'instructor' (text), and 'credits' (integer).",
          "initialData": [],
          "expectedResult": "CREATE TABLE courses (id INTEGER PRIMARY KEY, course_name TEXT, instructor TEXT, credits INTEGER);",
          "explanation": "This SQL command creates a 'courses' table with the necessary columns and their respective data types."
        },
        {
          "id": "sql-create-3",
          "question": "Explain the purpose of using constraints like 'PRIMARY KEY' or 'NOT NULL' in a `CREATE TABLE` statement.",
          "options": [
            "Constraints enforce database integrity and ensure data accuracy.",
            "Constraints define how the data is displayed.",
            "Constraints limit the number of rows in a table.",
            "Constraints automatically format the data."
          ],
          "answer": "Constraints enforce database integrity and ensure data accuracy.",
          "explanation": "Constraints such as 'PRIMARY KEY' and 'NOT NULL' ensure that certain conditions are met when data is inserted into the table, such as uniqueness or mandatory fields."
        }
      ]
    },
    {
      "id": "sql-edge-cases",
      "type": "topic",
      "title": "SQL Edge Cases",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-edge-1",
          "question": "What happens if the `COUNT()` function is used on an empty set?",
          "options": [
            "It returns 0.",
            "It returns NULL.",
            "It returns 1.",
            "It throws an error."
          ],
          "answer": "It returns 0.",
          "explanation": "The `COUNT()` function will return 0 when used on an empty set, as there are no rows to count."
        },
        {
          "id": "sql-edge-2",
          "question": "What does SQL return if a query attempts to insert a duplicate value into a column with a 'UNIQUE' constraint?",
          "options": [
            "The query succeeds but the duplicate value is ignored.",
            "The query fails and an error is thrown.",
            "The query automatically adjusts the value.",
            "The query partially succeeds, inserting non-duplicate rows."
          ],
          "answer": "The query fails and an error is thrown.",
          "explanation": "A 'UNIQUE' constraint ensures that all values in a column are unique. If an attempt is made to insert a duplicate, the query will fail with an error."
        },
        {
          "id": "sql-edge-3",
          "question": "What happens if you attempt to divide by zero in a SQL query?",
          "options": [
            "SQL returns NULL.",
            "SQL returns 0.",
            "SQL throws an error.",
            "SQL allows the operation to continue."
          ],
          "answer": "SQL throws an error.",
          "explanation": "In most SQL implementations, dividing by zero results in an error because it is an undefined mathematical operation."
        },
        {
          "id": "sql-edge-4",
          "question": "What is the behavior of LIMIT and OFFSET when their values exceed the number of rows in the result set?",
          "options": [
            "It raises an error",
            "It returns all available rows",
            "It returns an empty result set",
            "It depends on the LIMIT and OFFSET values"
          ],
          "answer": "It depends on the LIMIT and OFFSET values",
          "explanation": "If OFFSET exceeds the number of rows, an empty result set is returned. If LIMIT exceeds the remaining rows after OFFSET, all remaining rows are returned. No error is raised in either case."
        },
        {
          "id": "sql-edge-5",
          "question": "What is the result of comparing NULL to NULL using the = operator?",
          "options": [
            "TRUE",
            "FALSE",
            "NULL",
            "It depends on the database system"
          ],
          "answer": "NULL",
          "explanation": "When comparing NULL to NULL using the = operator, the result is NULL, not TRUE. This is because NULL represents an unknown value, and comparing two unknown values doesn't yield a boolean result. To check if a value is NULL, use IS NULL instead."
        },
        {
          "id": "sql-edge-6",
          "question": "What is the result of using LIMIT 0 in a SELECT statement?",
          "options": [
            "An empty result set",
            "The first row of the result",
            "An error",
            "All rows in the table"
          ],
          "answer": "An empty result set",
          "explanation": "Using LIMIT 0 in a SELECT statement returns an empty result set. This can be useful for checking the structure of a result without retrieving any actual data."
        }
      ]
    },
    {
      "id": "sql-views",
      "type": "topic",
      "title": "SQL Views",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-views-1",
          "question": "What is a SQL view?",
          "options": [
            "A temporary table that only exists during the current session.",
            "A stored query that behaves like a table.",
            "A backup of a table.",
            "A command that formats data output."
          ],
          "answer": "A stored query that behaves like a table.",
          "explanation": "A SQL view is essentially a saved query that behaves like a table, allowing you to query it as if it were a normal table."
        },
        {
          "id": "sql-views-2",
          "question": "Write a SQL query to create a view named 'student_orders' that shows all students and their corresponding orders.",
          "initialData": [
            "CREATE TABLE students (id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE orders (id INTEGER PRIMARY KEY, student_id INTEGER, product TEXT, FOREIGN KEY(student_id) REFERENCES students(id));",
            "INSERT INTO students (id, name) VALUES (1, 'John Doe'), (2, 'Jane Smith');",
            "INSERT INTO orders (id, student_id, product) VALUES (1, 1, 'Laptop'), (2, 1, 'Mouse'), (3, 2, 'Keyboard');"
          ],
          "expectedResult": "CREATE VIEW student_orders AS SELECT s.name, o.product FROM students s JOIN orders o ON s.id = o.student_id;",
          "explanation": "This query creates a view named 'student_orders' that combines data from both the 'students' and 'orders' tables using a JOIN."
        },
        {
          "id": "sql-views-3",
          "question": "Can a SQL view be updated directly? Explain your answer.",
          "options": [
            "Yes, always.",
            "No, never.",
            "Yes, but only under certain conditions.",
            "Yes, but the view is deleted afterward."
          ],
          "answer": "Yes, but only under certain conditions.",
          "explanation": "A view can be updated directly if it is based on a single table and doesn't include complex calculations or joins. However, if it includes multiple tables, aggregate functions, or `DISTINCT`, it cannot be updated."
        },
        {
          "id": "sql-views-4",
          "question": "What is a materialized view, and how does it differ from a regular SQL view?",
          "options": [
            "A materialized view stores the query results physically, while a regular view does not.",
            "A materialized view cannot be updated, while a regular view can.",
            "A materialized view is created automatically by the database, while a regular view is not.",
            "A materialized view stores the query, while a regular view stores the results."
          ],
          "answer": "A materialized view stores the query results physically, while a regular view does not.",
          "explanation": "A materialized view is a snapshot of a query's result set that is physically stored in the database. In contrast, a regular view is a virtual table that re-executes the query whenever it is accessed."
        }
      ]
    },
    {
      "id": "encryption-security",
      "type": "topic",
      "title": "Encryption and Security",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "encryption-security-1",
          "question": "What is hashing in the context of data security?",
          "options": [
            "The process of converting plaintext data into a fixed-size string of characters.",
            "A method of encrypting data with a public key.",
            "A technique used to verify the integrity of data.",
            "A way to store passwords securely."
          ],
          "answer": "The process of converting plaintext data into a fixed-size string of characters.",
          "explanation": "Hashing transforms data into a fixed-length string, making it difficult to reverse-engineer the original data."
        },
        {
          "id": "encryption-security-2",
          "question": "What is the purpose of 'salting' in password hashing?",
          "options": [
            "To add a random value to the password before hashing it.",
            "To encrypt the password with a private key.",
            "To create a checksum of the password.",
            "To make the password longer."
          ],
          "answer": "To add a random value to the password before hashing it.",
          "explanation": "Salting adds a unique random value to each password, making it more resistant to rainbow table attacks."
        },
        {
          "id": "encryption-security-3",
          "question": "What is a checksum?",
          "options": [
            "A technique to secure data using encryption.",
            "A value used to verify the integrity of data.",
            "A method of encoding data for storage.",
            "An algorithm to generate random values."
          ],
          "answer": "A value used to verify the integrity of data.",
          "explanation": "A checksum is a computed value that helps to detect errors in data during transmission or storage."
        },
        {
          "id": "encryption-security-4",
          "question": "What does end-to-end encryption (E2EE) ensure?",
          "options": [
            "Only the sender and recipient can read the messages.",
            "Messages are stored securely on a server.",
            "Encryption keys are shared publicly.",
            "Data is compressed before transmission."
          ],
          "answer": "Only the sender and recipient can read the messages.",
          "explanation": "E2EE ensures that data is encrypted on the sender's device and only decrypted on the recipient's device, preventing intermediaries from accessing it."
        },
        {
          "id": "encryption-security-5",
          "question": "What is the main feature of public/private key encryption?",
          "options": [
            "It uses a single key for both encryption and decryption.",
            "It uses two different keys for encryption and decryption.",
            "It does not require any keys.",
            "It is only used for symmetric encryption."
          ],
          "answer": "It uses two different keys for encryption and decryption.",
          "explanation": "Public/private key encryption uses a public key for encryption and a corresponding private key for decryption, enhancing security."
        },
        {
          "id": "encryption-security-6",
          "question": "What is symmetric encryption?",
          "options": [
            "A method where the same key is used for both encryption and decryption.",
            "A technique that uses two different keys.",
            "A form of encryption that does not require a key.",
            "A method of hashing data."
          ],
          "answer": "A method where the same key is used for both encryption and decryption.",
          "explanation": "In symmetric encryption, the same key must be kept secret and is used for both encrypting and decrypting the data."
        },
        {
          "id": "encryption-security-7",
          "question": "Which of the following algorithms is commonly used for hashing?",
          "options": [
            "AES",
            "RSA",
            "SHA-256",
            "Diffie-Hellman"
          ],
          "answer": "SHA-256",
          "explanation": "SHA-256 is a widely used hashing algorithm that produces a 256-bit hash value."
        },
        {
          "id": "encryption-security-8",
          "question": "What does the term 'key exchange' refer to?",
          "options": [
            "The process of swapping symmetric keys between parties.",
            "The method of securely sharing public keys.",
            "A protocol for sending encrypted messages.",
            "The generation of new keys for encryption."
          ],
          "answer": "The process of swapping symmetric keys between parties.",
          "explanation": "Key exchange refers to the methods used to securely share cryptographic keys, allowing encrypted communication."
        },
        {
          "id": "encryption-security-9",
          "question": "In which scenario would you use symmetric encryption?",
          "options": [
            "When you need to securely send a message to multiple recipients.",
            "When both the sender and receiver can securely share a key.",
            "When you need to encrypt data at rest.",
            "When you want to avoid key management complexities."
          ],
          "answer": "When both the sender and receiver can securely share a key.",
          "explanation": "Symmetric encryption is efficient when the same key is shared between parties that can securely exchange it."
        },
        {
          "id": "encryption-security-10",
          "question": "Which of the following is NOT a characteristic of hashing?",
          "options": [
            "Deterministic output.",
            "Reversible process.",
            "Fixed-size output.",
            "Collision-resistant."
          ],
          "answer": "Reversible process.",
          "explanation": "Hashing is a one-way function, meaning it cannot be reversed to obtain the original input."
        },
        {
          "id": "encryption-security-11",
          "question": "What is the primary purpose of using salts in password storage?",
          "options": [
            "To increase the length of the password.",
            "To create unique hashes for the same password.",
            "To improve hashing speed.",
            "To encrypt the password before storage."
          ],
          "answer": "To create unique hashes for the same password.",
          "explanation": "Salts ensure that even identical passwords have unique hashes, enhancing security against dictionary attacks."
        },
        {
          "id": "encryption-security-12",
          "question": "What is the primary risk of not using encryption for sensitive data?",
          "options": [
            "Data can be accessed without authorization.",
            "Data will be automatically deleted.",
            "Data will be corrupted.",
            "Data will be publicly visible."
          ],
          "answer": "Data can be accessed without authorization.",
          "explanation": "Without encryption, sensitive data is vulnerable to unauthorized access and potential data breaches."
        }
      ]
    }
  ]
  
}
