{
  "version": 15,
  "sections": [
    {
      "id": "entity-relationship-diagrams",
      "type": "topic",
      "title": "Entity-Relationship Diagrams I",
      "difficulty": "Easy",
      "questions": [
        {
          "id": "erd-q1",
          "question": "What is the purpose of the Entity-Relationship (E/R) Model?",
          "options": [
            "To describe a system for designing a web page",
            "To describe the database and capture constraints",
            "To build front-end interfaces",
            "To represent server connections"
          ],
          "answer": "To describe the database and capture constraints",
          "explanation": "The E/R model is used to describe the system we want to represent in a database, including its constraints."
        },
        {
          "id": "erd-q2",
          "question": "What shape is used to represent an Entity Set in an ER Diagram?",
          "options": ["Diamond", "Rectangle", "Oval", "Circle"],
          "answer": "Rectangle",
          "explanation": "In an ER diagram, an entity set is represented by a rectangle."
        },
        {
          "id": "erd-q3",
          "question": "Which shape is used to represent attributes in an Entity-Relationship Diagram?",
          "options": ["Diamond", "Oval", "Rectangle", "Triangle"],
          "answer": "Oval",
          "explanation": "In an ER diagram, attributes are represented by ovals connected to their respective entities."
        },
        {
          "id": "erd-q4",
          "question": "What does a diamond represent in an ER diagram?",
          "options": ["Entity", "Attribute", "Relationship", "Primary Key"],
          "answer": "Relationship",
          "explanation": "In an ER diagram, a diamond is used to represent relationships between entities."
        },
        {
          "id": "erd-q5",
          "question": "Which of the following is an example of an Entity Set?",
          "options": ["Player", "name", "position", "Team"],
          "answer": "Player",
          "explanation": "An entity set is a collection of similar entities, such as 'Player' in a sports system."
        },
        {
          "id": "erd-q6",
          "question": "What is an Entity Set?",
          "options": [
            "A collection of similar entities",
            "A collection of relationships between entities",
            "A unique identifier for an entity",
            "A set of attributes"
          ],
          "answer": "A collection of similar entities",
          "explanation": "An entity set is a collection of similar entities, like all 'Players' in a sports team."
        },
        {
          "id": "erd-q7",
          "question": "In an ER Diagram, what is represented by a relationship?",
          "options": [
            "An attribute connecting two entity sets",
            "A diamond representing the connection between two or more entity sets",
            "A connection between an attribute and an entity set",
            "A unique identifier for each entity"
          ],
          "answer": "A diamond representing the connection between two or more entity sets",
          "explanation": "A relationship is represented by a diamond connecting two or more entity sets in an ER diagram."
        },
        {
          "id": "erd-q8",
          "question": "What type of attribute cannot be used in an ER diagram?",
          "options": [
            "String",
            "Integer",
            "List or collection",
            "Date"
          ],
          "answer": "List or collection",
          "explanation": "Attributes in ER diagrams must be simple, meaning they cannot be lists, collections, or composite structures."
        },
        {
          "id": "erd-q9",
          "question": "What is the value of an entity set?",
          "options": [
            "The attributes it contains",
            "The relationships it has",
            "The set of entities that belong to it",
            "Its primary key"
          ],
          "answer": "The set of entities that belong to it",
          "explanation": "The value of an entity set is the collection of entities that belong to that set."
        },
        {
          "id": "erd-q10",
          "question": "What is a primary key in the context of an ER diagram?",
          "options": [
            "An attribute that uniquely identifies each entity in an entity set",
            "An attribute that represents a relationship between two entities",
            "A set of entities that are related to each other",
            "A graphical symbol used in ER diagrams"
          ],
          "answer": "An attribute that uniquely identifies each entity in an entity set",
          "explanation": "A primary key is an attribute (or set of attributes) that uniquely identifies each entity in an entity set."
        }
      ]
    },
    {
      "id": "sql-basics-I",
      "type": "topic",
      "title": "SQL Basics I",
      "difficulty": "Easy",
      "questions": [
        {
          "id": "sqlb1-q1",
          "question": "What does SQL stand for?",
          "options": [
            "Structured Query Language",
            "Simple Question Language",
            "Structured Question Logic",
            "System Query Language"
          ],
          "answer": "Structured Query Language",
          "explanation": "SQL stands for Structured Query Language, which is used for managing and manipulating relational databases."
        },
        {
          "id": "sqlb1-q2",
          "question": "Write a SQL query to select all columns from the 'users' table.",
          "initialData": [
            "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT);",
            "INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');",
            "INSERT INTO users (name, email) VALUES ('Jane Smith', 'jane@example.com');"
          ],
          "expectedResult": "SELECT * FROM users;",
          "explanation": "The query 'SELECT * FROM users;' selects all columns and rows from the 'users' table."
        },
        {
          "id": "sqlb1-q3",
          "question": "Suppose you have two tables, 'users' and 'orders'. The 'users' table has columns 'id', 'name', and 'email'. The 'orders' table has columns 'id', 'user_id', 'product', and 'order_date'. Write a SQL query to list all users along with the number of orders they have placed. Make sure you have columns id, name, and email in that order. The list should include users who have not placed any orders.",
          "initialData": [
            "CREATE TABLE users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT UNIQUE NOT NULL ); CREATE TABLE orders ( id INTEGER PRIMARY KEY, user_id INTEGER, product TEXT NOT NULL, order_date DATE NOT NULL, FOREIGN KEY(user_id) REFERENCES users(id) ); INSERT INTO users (id, name, email) VALUES (1, 'John Doe', 'john@example.com'), (2, 'Jane Smith', 'jane@sample.com'), (3, 'Alice Johnson', 'alice@example.com'), (4, 'Bob Brown', 'bob@another.com'); INSERT INTO orders (id, user_id, product, order_date) VALUES (1, 1, 'Laptop', '2023-01-15'), (2, 1, 'Mouse', '2023-02-20'), (3, 3, 'Keyboard', '2023-03-10');"
          ],
          "expectedResult": "SELECT u.id, u.name, u.email, COUNT(o.id) AS order_count FROM users u LEFT JOIN orders o ON u.id = o.user_id GROUP BY u.id, u.name, u.email;",
          "explanation": "This query performs a LEFT JOIN between the 'users' and 'orders' tables to ensure all users are included, even those without any orders. It then groups the results by user ID and name, counting the number of orders each user has placed using the COUNT() function. Users with no orders will have an order_count of 0."
        },
        {
          "id": "sqlb1-q4",
          "question": "Retrieve all records from the 'users' table.",
          "initialData": [
            "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);",
            "INSERT INTO users (name) VALUES ('Alice'), ('Bob');"
          ],
          "expectedResult": "SELECT * FROM users;",
          "explanation": "By using SELECT * you can select all columns of the table."
        }
        
      ]
    },
    {
      "id": "sql-basics-II",
      "type": "topic",
      "title": "SQL Basics II",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-basics-1",
          "question": "Write a SQL query to return the total number of unique book titles in the 'library' table.",
          "initialData": [
            "CREATE TABLE library (book_id INTEGER PRIMARY KEY, title TEXT, author TEXT, genre TEXT);",
            "INSERT INTO library (title, author, genre) VALUES ('The Great Gatsby', 'F. Scott Fitzgerald', 'Fiction'), ('Moby Dick', 'Herman Melville', 'Fiction'), ('The Great Gatsby', 'F. Scott Fitzgerald', 'Fiction');"
          ],
          "expectedResult": "SELECT COUNT(DISTINCT title) FROM library;",
          "explanation": "This query counts the number of distinct book titles in the 'library' table."
        },
        {
          "id": "sql-basics-2",
          "question": "Write a SQL query to return all employees from the 'employees' table, ordered by salary from highest to lowest.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, salary DECIMAL);",
            "INSERT INTO employees (name, salary) VALUES ('John', 55000), ('Jane', 72000), ('Emily', 60000);"
          ],
          "expectedResult": "SELECT * FROM employees ORDER BY salary DESC;",
          "explanation": "This query selects all columns from the 'employees' table and orders the results by salary in descending order."
        },
        {
          "id": "sql-basics-3",
          "question": "Write a SQL query to create a table called 'students' with columns: student_id (integer, primary key), name (text), age (integer), and major (text).",
          "initialData": [],
          "expectedResult": "CREATE TABLE students (student_id INTEGER PRIMARY KEY, name TEXT, age INTEGER, major TEXT);",
          "explanation": "This query creates a 'students' table with columns for student ID, name, age, and major, defining 'student_id' as the primary key."
        },
        {
          "id": "sql-basics-4",
          "question": "Write a SQL query to return the names and ages of all students who are majoring in 'Computer Science'.",
          "initialData": [
            "CREATE TABLE students (student_id INTEGER PRIMARY KEY, name TEXT, age INTEGER, major TEXT);",
            "INSERT INTO students (name, age, major) VALUES ('Alice', 20, 'Computer Science'), ('Bob', 21, 'Mathematics'), ('Charlie', 22, 'Computer Science');"
          ],
          "expectedResult": "SELECT name, age FROM students WHERE major = 'Computer Science';",
          "explanation": "This query retrieves the 'name' and 'age' columns for students majoring in 'Computer Science'."
        },
        {
          "id": "sql-basics-5",
          "question": "What is the difference between `ORDER BY` and `GROUP BY` in SQL?",
          "options": [
            "`ORDER BY` sorts the result set, while `GROUP BY` groups rows with the same values in specified columns.",
            "`ORDER BY` groups rows with the same values, while `GROUP BY` sorts them.",
            "`ORDER BY` filters out duplicate rows, while `GROUP BY` displays all rows.",
            "`ORDER BY` is used only for text fields, while `GROUP BY` is used for numeric fields."
          ],
          "answer": "`ORDER BY` sorts the result set, while `GROUP BY` groups rows with the same values in specified columns.",
          "explanation": "`ORDER BY` is used to sort the result set, whereas `GROUP BY` groups rows that have the same values in specified columns, typically used with aggregate functions."
        },
        {
          "id": "sql-basics-6",
          "question": "Write a SQL query that groups students by their 'class' and counts the number of students in each class.",
          "initialData": [
            "CREATE TABLE students (id INTEGER PRIMARY KEY, name TEXT, class TEXT);",
            "INSERT INTO students (name, class) VALUES ('John Doe', 'CSE380'), ('Jane Smith', 'CSE380'), ('Bob Brown', 'CSE250');"
          ],
          "expectedResult": "SELECT class, COUNT(*) FROM students GROUP BY class;",
          "explanation": "This query groups students by their 'class' and counts the number of students in each group."
        },
        {
          "id": "sql-basics-7",
          "question": "What is the purpose of the `HAVING` clause in SQL?",
          "options": [
            "It filters the result set after grouping.",
            "It filters the result set before grouping.",
            "It sorts the result set based on aggregates.",
            "It combines two result sets into one."
          ],
          "answer": "It filters the result set after grouping.",
          "explanation": "The `HAVING` clause is used to filter groups of rows after the `GROUP BY` clause has been applied."
        }
      ]
    },
    
    {
      "id": "sql-joins",
      "type": "topic",
      "title": "SQL Joins",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-joins-1",
          "question": "What type of join is used to return all records from both tables, with matching records from both sides where available?",
          "options": [
            "INNER JOIN",
            "LEFT JOIN",
            "RIGHT JOIN",
            "FULL OUTER JOIN"
          ],
          "answer": "FULL OUTER JOIN",
          "explanation": "A FULL OUTER JOIN returns all rows from both tables, matching rows where possible, and filling in NULLs where there are no matches."
        },
        {
          "id": "sql-joins-2",
          "question": "Write a SQL query to return the names of students and the courses they are enrolled in, showing students even if they are not enrolled in any course. Use the 'students' and 'enrollments' tables.",
          "initialData": [
            "CREATE TABLE students (student_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE enrollments (student_id INTEGER, course_name TEXT);",
            "INSERT INTO students (student_id, name) VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');",
            "INSERT INTO enrollments (student_id, course_name) VALUES (1, 'Math'), (1, 'Science'), (3, 'History');"
          ],
          "expectedResult": "SELECT students.name, enrollments.course_name FROM students LEFT JOIN enrollments ON students.student_id = enrollments.student_id;",
          "explanation": "This query uses a LEFT JOIN to include all students, even those not enrolled in any courses. It matches students with their courses based on the 'student_id'."
        },
        {
          "id": "sql-joins-3",
          "question": "Write a SQL query to return the names of employees and their department names, but only show employees who are assigned to a department. Use the 'employees' and 'departments' tables.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, department_id INTEGER);",
            "CREATE TABLE departments (department_id INTEGER PRIMARY KEY, department_name TEXT);",
            "INSERT INTO employees (employee_id, name, department_id) VALUES (1, 'John', 101), (2, 'Jane', 102), (3, 'Emily', NULL);",
            "INSERT INTO departments (department_id, department_name) VALUES (101, 'HR'), (102, 'Engineering');"
          ],
          "expectedResult": "SELECT employees.name, departments.department_name FROM employees INNER JOIN departments ON employees.department_id = departments.department_id;",
          "explanation": "This query uses an INNER JOIN to return only employees who are assigned to a department, matching records on 'department_id'."
        },
        {
          "id": "sql-joins-4",
          "question": "Write a SQL query to return the names of all projects and the names of their assigned managers, even if the project has no manager. Use the 'projects' and 'managers' tables.",
          "initialData": [
            "CREATE TABLE projects (project_id INTEGER PRIMARY KEY, project_name TEXT, manager_id INTEGER);",
            "CREATE TABLE managers (manager_id INTEGER PRIMARY KEY, name TEXT);",
            "INSERT INTO projects (project_id, project_name, manager_id) VALUES (1, 'Project A', 1), (2, 'Project B', NULL);",
            "INSERT INTO managers (manager_id, name) VALUES (1, 'Michael');"
          ],
          "expectedResult": "SELECT projects.project_name, managers.name FROM projects LEFT JOIN managers ON projects.manager_id = managers.manager_id;",
          "explanation": "This query uses a LEFT JOIN to return all projects, including those without an assigned manager. Projects with no manager will have NULL for the manager name."
        }
      ]
    },
    {
      "id": "sql-joins-ii",
      "type": "topic",
      "title": "SQL Joins II",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-joins-ii-5",
          "question": "Write a SQL query to return the count of students enrolled in each course. Show the course name even if no students are enrolled. Use the 'courses' and 'enrollments' tables.",
          "initialData": [
            "CREATE TABLE courses (course_id INTEGER PRIMARY KEY, course_name TEXT);",
            "CREATE TABLE enrollments (student_id INTEGER, course_id INTEGER);",
            "INSERT INTO courses (course_id, course_name) VALUES (1, 'Math'), (2, 'Science'), (3, 'History');",
            "INSERT INTO enrollments (student_id, course_id) VALUES (1, 1), (2, 1), (3, 2);"
          ],
          "expectedResult": "SELECT courses.course_name, COUNT(enrollments.student_id) AS student_count FROM courses LEFT JOIN enrollments ON courses.course_id = enrollments.course_id GROUP BY courses.course_name;",
          "explanation": "This query uses a LEFT JOIN to show all courses, even those without students, and groups the result by course name to count the number of students enrolled in each course."
        },
        {
          "id": "sql-joins-ii-6",
          "question": "Write a SQL query to return the names of employees and their department names, ordered by department name. Use the 'employees' and 'departments' tables.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, department_id INTEGER);",
            "CREATE TABLE departments (department_id INTEGER PRIMARY KEY, department_name TEXT);",
            "INSERT INTO employees (employee_id, name, department_id) VALUES (1, 'John', 101), (2, 'Jane', 102), (3, 'Emily', 101);",
            "INSERT INTO departments (department_id, department_name) VALUES (101, 'HR'), (102, 'Engineering');"
          ],
          "expectedResult": "SELECT employees.name, departments.department_name FROM employees INNER JOIN departments ON employees.department_id = departments.department_id ORDER BY departments.department_name;",
          "explanation": "This query uses an INNER JOIN to return employees assigned to departments and orders the result by the department name."
        },
        {
          "id": "sql-joins-ii-7",
          "question": "Write a SQL query to return the names of all customers whose names contain the letter 'a', along with their order count. Use the 'customers' and 'orders' tables.",
          "initialData": [
            "CREATE TABLE customers (customer_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE orders (order_id INTEGER PRIMARY KEY, customer_id INTEGER);",
            "INSERT INTO customers (customer_id, name) VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');",
            "INSERT INTO orders (order_id, customer_id) VALUES (1, 1), (2, 1), (3, 3);"
          ],
          "expectedResult": "SELECT customers.name, COUNT(orders.order_id) AS order_count FROM customers LEFT JOIN orders ON customers.customer_id = orders.customer_id WHERE customers.name LIKE '%a%' GROUP BY customers.name;",
          "explanation": "This query uses a LEFT JOIN to return customers with their order count, including those with no orders. It filters the customers whose names contain the letter 'a' using the LIKE clause and groups the results by customer name."
        }
      ]
    },
    
    {
      "id": "sql-joins-iii",
      "type": "topic",
      "title": "SQL Joins III",
      "difficulty": "Hard",
      "questions": [
        {
          "id": "sql-joins-iii-1",
          "question": "Write a SQL query to return the names of employees, their department names, and their managers' names. Return all employees, including those without a department or manager. Use the 'employees', 'departments', and 'managers' tables.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, department_id INTEGER, manager_id INTEGER);",
            "CREATE TABLE departments (department_id INTEGER PRIMARY KEY, department_name TEXT);",
            "CREATE TABLE managers (manager_id INTEGER PRIMARY KEY, name TEXT);",
            "INSERT INTO employees (employee_id, name, department_id, manager_id) VALUES (1, 'John', 101, 1), (2, 'Jane', 102, 2), (3, 'Emily', NULL, 2);",
            "INSERT INTO departments (department_id, department_name) VALUES (101, 'HR'), (102, 'Engineering');",
            "INSERT INTO managers (manager_id, name) VALUES (1, 'Michael'), (2, 'Sarah');"
          ],
          "expectedResult": "SELECT employees.name AS employee_name, departments.department_name, managers.name AS manager_name FROM employees LEFT JOIN departments ON employees.department_id = departments.department_id LEFT JOIN managers ON employees.manager_id = managers.manager_id;",
          "explanation": "This query uses two LEFT JOINs to return all employees, including those without a department or manager, and matches them with their respective department and manager."
        },
        {
          "id": "sql-joins-iii-2",
          "question": "Write a SQL query to return the names of all products and the total quantity ordered for each product, including products that have never been ordered. Use the 'products' and 'orders' tables.",
          "initialData": [
            "CREATE TABLE products (product_id INTEGER PRIMARY KEY, product_name TEXT);",
            "CREATE TABLE orders (order_id INTEGER PRIMARY KEY, product_id INTEGER, quantity INTEGER);",
            "INSERT INTO products (product_id, product_name) VALUES (1, 'Laptop'), (2, 'Mouse'), (3, 'Keyboard');",
            "INSERT INTO orders (order_id, product_id, quantity) VALUES (1, 1, 10), (2, 1, 5), (3, 2, 20);"
          ],
          "expectedResult": "SELECT products.product_name, COALESCE(SUM(orders.quantity), 0) AS total_quantity FROM products LEFT JOIN orders ON products.product_id = orders.product_id GROUP BY products.product_name;",
          "explanation": "This query uses a LEFT JOIN to include all products, even those with no orders. The COALESCE function ensures that products without orders will have a total quantity of 0."
        },
        {
          "id": "sql-joins-iii-3",
          "question": "Write a SQL query to return the names of customers and the total amount they spent, including customers who have not placed any orders. Use the 'customers', 'orders', and 'order_items' tables.",
          "initialData": [
            "CREATE TABLE customers (customer_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE orders (order_id INTEGER PRIMARY KEY, customer_id INTEGER);",
            "CREATE TABLE order_items (order_item_id INTEGER PRIMARY KEY, order_id INTEGER, price DECIMAL);",
            "INSERT INTO customers (customer_id, name) VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');",
            "INSERT INTO orders (order_id, customer_id) VALUES (1, 1), (2, 1), (3, 3);",
            "INSERT INTO order_items (order_item_id, order_id, price) VALUES (1, 1, 50.00), (2, 1, 30.00), (3, 3, 70.00);"
          ],
          "expectedResult": "SELECT customers.name, COALESCE(SUM(order_items.price), 0) AS total_spent FROM customers LEFT JOIN orders ON customers.customer_id = orders.customer_id LEFT JOIN order_items ON orders.order_id = order_items.order_id GROUP BY customers.name;",
          "explanation": "This query uses LEFT JOINs to include customers who have not placed any orders and calculates the total amount spent for each customer. The COALESCE function ensures customers with no orders show a total of 0."
        },
        {
          "id": "sql-joins-iii-4",
          "question": "Write a SQL query to return the names of employees and their projects, including employees not assigned to any projects. Use the 'employees' and 'projects' tables.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE projects (project_id INTEGER PRIMARY KEY, project_name TEXT, employee_id INTEGER);",
            "INSERT INTO employees (employee_id, name) VALUES (1, 'John'), (2, 'Jane'), (3, 'Emily');",
            "INSERT INTO projects (project_id, project_name, employee_id) VALUES (1, 'Project A', 1), (2, 'Project B', NULL);"
          ],
          "expectedResult": "SELECT employees.name AS employee_name, projects.project_name FROM employees LEFT JOIN projects ON employees.employee_id = projects.employee_id;",
          "explanation": "This query uses a LEFT JOIN to return all employees, including those without any projects, and matches them with their respective project if assigned."
        },
        {
          "id": "sql-joins-iii-5",
          "question": "Write a SQL query to return all departments and the total number of employees in each department, including departments with no employees. Use the 'departments' and 'employees' tables.",
          "initialData": [
            "CREATE TABLE departments (department_id INTEGER PRIMARY KEY, department_name TEXT);",
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, department_id INTEGER);",
            "INSERT INTO departments (department_id, department_name) VALUES (101, 'HR'), (102, 'Engineering'), (103, 'Finance');",
            "INSERT INTO employees (employee_id, department_id) VALUES (1, 101), (2, 102), (3, 101);"
          ],
          "expectedResult": "SELECT departments.department_name, COUNT(employees.employee_id) AS employee_count FROM departments LEFT JOIN employees ON departments.department_id = employees.department_id GROUP BY departments.department_name;",
          "explanation": "This query uses a LEFT JOIN to include all departments, even those with no employees. The COUNT function ensures departments without employees will return a count of 0."
        }
      ]
    },
    {
      "id": "json-web-tokens",
      "type": "topic",
      "title": "JSON Web Tokens (JWTs)",
      "difficulty": "Easy",
      "questions": [
        {
          "id": "jwt-1",
          "question": "What is a JSON Web Token (JWT) used for?",
          "options": [
            "To encrypt data",
            "To represent a set of permissions for a user",
            "To securely transmit information between parties as a JSON object",
            "To store information in a database"
          ],
          "answer": "To securely transmit information between parties as a JSON object",
          "explanation": "JWTs are used to securely transmit information between parties as a JSON object, typically for authentication and authorization."
        },
        {
          "id": "jwt-2",
          "question": "What are the three parts of a JWT?",
          "options": [
            "Header, Payload, Signature",
            "Header, Body, Footer",
            "Session, Token, Payload",
            "Request, Response, Signature"
          ],
          "answer": "Header, Payload, Signature",
          "explanation": "A JWT consists of three parts: the header, which defines the type of token and algorithm; the payload, which contains the claims; and the signature, which verifies the token's integrity."
        },
        {
          "id": "jwt-3",
          "question": "Which of the following is NOT typically included in the JWT header?",
          "options": [
            "The algorithm used",
            "The token type",
            "The user's password",
            "The key ID (kid)"
          ],
          "answer": "The user's password",
          "explanation": "The JWT header usually includes the algorithm and token type, but sensitive data like passwords are not included."
        },
        {
          "id": "jwt-4",
          "question": "How is a JWT typically encoded?",
          "options": [
            "Base64-encoded",
            "Hexadecimal-encoded",
            "Encrypted using RSA",
            "ASCII-encoded"
          ],
          "answer": "Base64-encoded",
          "explanation": "JWTs are Base64-encoded to ensure that the token can be easily transmitted over HTTP, which requires URL-safe characters."
        },
        {
          "id": "jwt-5",
          "question": "What is the purpose of the signature in a JWT?",
          "options": [
            "To encrypt the payload",
            "To verify that the token has not been tampered with",
            "To compress the token",
            "To sign the user out"
          ],
          "answer": "To verify that the token has not been tampered with",
          "explanation": "The signature ensures the integrity of the JWT by verifying that the token has not been altered after it was issued."
        },
        {
          "id": "jwt-6",
          "question": "What is the middle part of a JWT?",
          "options": [
            "The base 64 header",
            "The signature",
            "The base 64 payload",
            "The base 64 signature"
          ],
          "answer": "The base 64 payload",
          "explanation": "The middle part of the JWT is the Base64-encoded payload."
        }
      ]
    },
    {
      "id": "json-web-tokens-advanced",
      "type": "topic",
      "title": "JSON Web Tokens (JWTs) - Advanced",
      "difficulty": "Hard",
      "questions": [
        {
          "id": "jwt-advanced-1",
          "question": "What algorithm is used in a JWT with the header specifying 'alg': 'HS256'?",
          "options": [
            "HMAC using SHA-256",
            "RSA using SHA-256",
            "Elliptic Curve using SHA-256",
            "MD5 with HMAC"
          ],
          "answer": "HMAC using SHA-256",
          "explanation": "HS256 specifies the use of HMAC with SHA-256 to create the signature in the JWT, combining the secret key with the hash algorithm."
        },
        {
          "id": "jwt-advanced-2",
          "question": "What vulnerability could arise if a JWT token's algorithm is changed from RS256 to none?",
          "options": [
            "The token can be altered without needing to resign it",
            "The payload becomes encrypted",
            "The token becomes invalid",
            "The signature becomes more secure"
          ],
          "answer": "The token can be altered without needing to resign it",
          "explanation": "If the algorithm is set to 'none,' the token's signature is effectively disabled, allowing attackers to modify the payload without needing to re-sign the token."
        },
        {
          "id": "jwt-advanced-3",
          "question": "Which of the following is a best practice for securing JWTs?",
          "options": [
            "Storing JWTs in local storage",
            "Storing JWTs in cookies with the 'HttpOnly' and 'Secure' flags",
            "Encoding the payload using Base64",
            "Using 'none' as the algorithm for quicker verification"
          ],
          "answer": "Storing JWTs in cookies with the 'HttpOnly' and 'Secure' flags",
          "explanation": "JWTs should be stored in secure cookies with 'HttpOnly' to prevent JavaScript access and 'Secure' to ensure they're transmitted over HTTPS only."
        },
        {
          "id": "jwt-advanced-4",
          "question": "What is the primary difference between symmetric and asymmetric encryption in the context of JWTs?",
          "options": [
            "Symmetric encryption uses one key, while asymmetric encryption uses a public/private key pair",
            "Symmetric encryption is faster but less secure than asymmetric encryption",
            "Symmetric encryption always requires a password, while asymmetric encryption does not",
            "Symmetric encryption is used in JWT signatures, while asymmetric encryption is not"
          ],
          "answer": "Symmetric encryption uses one key, while asymmetric encryption uses a public/private key pair",
          "explanation": "In JWTs, symmetric encryption (e.g., HS256) uses a single secret key for both signing and verifying, while asymmetric encryption (e.g., RS256) uses a public/private key pair for signing and verification."
        },
        {
          "id": "jwt-advanced-5",
          "question": "Which claim is used in JWTs to define an expiration time for the token?",
          "options": [
            "iat",
            "nbf",
            "exp",
            "sub"
          ],
          "answer": "exp",
          "explanation": "The 'exp' (expiration) claim is used to define the time at which the JWT will expire. After this time, the token is no longer valid."
        },
        {
          "id": "jwt-advanced-6",
          "question": "What potential security risk exists if the 'exp' claim is omitted from a JWT?",
          "options": [
            "The token will never expire and can be used indefinitely",
            "The token will automatically expire after 24 hours",
            "The token becomes invalid immediately",
            "The token can only be used once"
          ],
          "answer": "The token will never expire and can be used indefinitely",
          "explanation": "Without the 'exp' claim, the token doesn't have an expiration time, meaning it could be reused indefinitely if it is not invalidated by other means."
        }
      ]
    },
    {
      "id": "sql-create-table",
      "type": "topic",
      "title": "SQL CREATE TABLE I",
      "difficulty": "Easy",
      "questions": [
        {
          "id": "sql-create-1",
          "question": "What is the basic syntax for creating a table in SQL?",
          "options": [
            "CREATE DATABASE table_name (column_name data_type);",
            "INSERT INTO table_name (column_name data_type);",
            "CREATE TABLE table_name (column_name data_type);",
            "SELECT * FROM table_name;"
          ],
          "answer": "CREATE TABLE table_name (column_name data_type);",
          "explanation": "The basic syntax for creating a table in SQL is 'CREATE TABLE table_name (column_name data_type);'."
        },
        {
          "id": "sql-create-2",
          "question": "Write a `CREATE TABLE` statement to create a 'courses' table with the following columns: 'id' (integer primary key), 'course_name' (text), 'instructor' (text), and 'credits' (integer).",
          "initialData": [],
          "expectedResult": "CREATE TABLE courses (id INTEGER PRIMARY KEY, course_name TEXT, instructor TEXT, credits INTEGER);",
          "explanation": "This SQL command creates a 'courses' table with the necessary columns and their respective data types."
        },
        {
          "id": "sql-create-3",
          "question": "Explain the purpose of using constraints like 'PRIMARY KEY' or 'NOT NULL' in a `CREATE TABLE` statement.",
          "options": [
            "Constraints enforce database integrity and ensure data accuracy.",
            "Constraints define how the data is displayed.",
            "Constraints limit the number of rows in a table.",
            "Constraints automatically format the data."
          ],
          "answer": "Constraints enforce database integrity and ensure data accuracy.",
          "explanation": "Constraints such as 'PRIMARY KEY' and 'NOT NULL' ensure that certain conditions are met when data is inserted into the table, such as uniqueness or mandatory fields."
        }
      ]
    },
    {
      "id": "sql-edge-cases",
      "type": "topic",
      "title": "SQL Edge Cases",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-edge-1",
          "question": "What happens if the `COUNT()` function is used on an empty set?",
          "options": [
            "It returns 0.",
            "It returns NULL.",
            "It returns 1.",
            "It throws an error."
          ],
          "answer": "It returns 0.",
          "explanation": "The `COUNT()` function will return 0 when used on an empty set, as there are no rows to count."
        },
        {
          "id": "sql-edge-2",
          "question": "What does SQL return if a query attempts to insert a duplicate value into a column with a 'UNIQUE' constraint?",
          "options": [
            "The query succeeds but the duplicate value is ignored.",
            "The query fails and an error is thrown.",
            "The query automatically adjusts the value.",
            "The query partially succeeds, inserting non-duplicate rows."
          ],
          "answer": "The query fails and an error is thrown.",
          "explanation": "A 'UNIQUE' constraint ensures that all values in a column are unique. If an attempt is made to insert a duplicate, the query will fail with an error."
        },
        {
          "id": "sql-edge-3",
          "question": "What happens if you attempt to divide by zero in a SQL query?",
          "options": [
            "SQL returns NULL.",
            "SQL returns 0.",
            "SQL throws an error.",
            "SQL allows the operation to continue."
          ],
          "answer": "SQL throws an error.",
          "explanation": "In most SQL implementations, dividing by zero results in an error because it is an undefined mathematical operation."
        },
        {
          "id": "sql-edge-4",
          "question": "What is the behavior of LIMIT and OFFSET when their values exceed the number of rows in the result set?",
          "options": [
            "It raises an error",
            "It returns all available rows",
            "It returns an empty result set",
            "It depends on the LIMIT and OFFSET values"
          ],
          "answer": "It depends on the LIMIT and OFFSET values",
          "explanation": "If OFFSET exceeds the number of rows, an empty result set is returned. If LIMIT exceeds the remaining rows after OFFSET, all remaining rows are returned. No error is raised in either case."
        },
        {
          "id": "sql-edge-5",
          "question": "What is the result of comparing NULL to NULL using the = operator?",
          "options": [
            "TRUE",
            "FALSE",
            "NULL",
            "It depends on the database system"
          ],
          "answer": "NULL",
          "explanation": "When comparing NULL to NULL using the = operator, the result is NULL, not TRUE. This is because NULL represents an unknown value, and comparing two unknown values doesn't yield a boolean result. To check if a value is NULL, use IS NULL instead."
        },
        {
          "id": "sql-edge-6",
          "question": "What is the result of using LIMIT 0 in a SELECT statement?",
          "options": [
            "An empty result set",
            "The first row of the result",
            "An error",
            "All rows in the table"
          ],
          "answer": "An empty result set",
          "explanation": "Using LIMIT 0 in a SELECT statement returns an empty result set. This can be useful for checking the structure of a result without retrieving any actual data."
        }
      ]
    },
    
    {
      "id": "sql-edge-cases-ii",
      "type": "topic",
      "title": "SQL Edge Cases II",
      "difficulty": "Hard",
      "questions": [
        {
          "id": "sql-edge-ii-1",
          "question": "What happens if a GROUP BY column contains NULL values?",
          "options": [
            "The query fails with an error.",
            "Rows with NULL values are excluded from the result.",
            "Rows with NULL values are grouped together.",
            "Each NULL value is treated as a separate group."
          ],
          "answer": "Rows with NULL values are grouped together.",
          "explanation": "In SQL, rows with NULL values in a GROUP BY column are grouped together in a single group because NULL is treated as an unknown value but is grouped as one set."
        },
        {
          "id": "sql-edge-ii-2",
          "question": "What is the result of a LEFT JOIN when there are no matching rows in the right table?",
          "options": [
            "An empty result set.",
            "The query fails with an error.",
            "NULLs are returned for columns from the right table.",
            "Rows from the left table are excluded from the result."
          ],
          "answer": "NULLs are returned for columns from the right table.",
          "explanation": "In a LEFT JOIN, if there are no matching rows in the right table, SQL will return NULLs for the columns of the right table while including all rows from the left table."
        },
        {
          "id": "sql-edge-ii-3",
          "question": "What is the result of using the HAVING clause without a GROUP BY?",
          "options": [
            "The query succeeds but ignores the HAVING clause.",
            "The query fails with an error.",
            "The HAVING clause acts as a WHERE clause.",
            "The query returns an empty result set."
          ],
          "answer": "The HAVING clause acts as a WHERE clause.",
          "explanation": "In some SQL implementations, if a HAVING clause is used without a GROUP BY clause, it behaves like a WHERE clause, filtering rows based on the conditions specified."
        },
        {
          "id": "sql-edge-ii-4",
          "question": "What happens when a subquery returns more than one row in a single-row subquery context (e.g., in a WHERE clause using '=')?",
          "options": [
            "The query returns the first row from the subquery.",
            "SQL throws an error.",
            "SQL ignores the additional rows and proceeds with the first one.",
            "SQL returns all rows from the subquery."
          ],
          "answer": "SQL throws an error.",
          "explanation": "If a subquery returns more than one row when only a single value is expected (as in a single-row subquery), SQL will throw an error, as it cannot compare multiple values with a scalar value."
        },
        {
          "id": "sql-edge-ii-5",
          "question": "What happens when you use UNION ALL instead of UNION, but the result sets contain duplicate rows?",
          "options": [
            "Duplicate rows are automatically removed.",
            "An error is thrown due to duplicates.",
            "The duplicate rows are included in the result.",
            "The result set ignores all duplicates and returns distinct rows."
          ],
          "answer": "The duplicate rows are included in the result.",
          "explanation": "UNION ALL includes all rows, including duplicates, in the result set, whereas UNION removes duplicate rows."
        },
        {
          "id": "sql-edge-ii-6",
          "question": "What is the behavior when an aggregate function like SUM() is applied to a column that contains only NULL values?",
          "options": [
            "The result is NULL.",
            "The result is 0.",
            "The query fails with an error.",
            "The result is undefined."
          ],
          "answer": "The result is 0.",
          "explanation": "When an aggregate function like SUM() is applied to a column containing only NULL values, the result is 0. Aggregate functions generally ignore NULL values."
        }
      ]
    },
    {
      "id": "sql-views",
      "type": "topic",
      "title": "SQL Views",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-views-1",
          "question": "What is a SQL view?",
          "options": [
            "A temporary table that only exists during the current session.",
            "A stored query that behaves like a table.",
            "A backup of a table.",
            "A command that formats data output."
          ],
          "answer": "A stored query that behaves like a table.",
          "explanation": "A SQL view is essentially a saved query that behaves like a table, allowing you to query it as if it were a normal table."
        },
        {
          "id": "sql-views-2",
          "question": "Write a SQL query to create a view named 'student_orders' that shows all students and their corresponding orders.",
          "initialData": [
            "CREATE TABLE students (id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE orders (id INTEGER PRIMARY KEY, student_id INTEGER, product TEXT, FOREIGN KEY(student_id) REFERENCES students(id));",
            "INSERT INTO students (id, name) VALUES (1, 'John Doe'), (2, 'Jane Smith');",
            "INSERT INTO orders (id, student_id, product) VALUES (1, 1, 'Laptop'), (2, 1, 'Mouse'), (3, 2, 'Keyboard');"
          ],
          "expectedResult": "CREATE VIEW student_orders AS SELECT s.name, o.product FROM students s JOIN orders o ON s.id = o.student_id;",
          "explanation": "This query creates a view named 'student_orders' that combines data from both the 'students' and 'orders' tables using a JOIN."
        },
        {
          "id": "sql-views-3",
          "question": "Can a SQL view be updated directly? Explain your answer.",
          "options": [
            "Yes, always.",
            "No, never.",
            "Yes, but only under certain conditions.",
            "Yes, but the view is deleted afterward."
          ],
          "answer": "Yes, but only under certain conditions.",
          "explanation": "A view can be updated directly if it is based on a single table and doesn't include complex calculations or joins. However, if it includes multiple tables, aggregate functions, or `DISTINCT`, it cannot be updated."
        },
        {
          "id": "sql-views-4",
          "question": "What is a materialized view, and how does it differ from a regular SQL view?",
          "options": [
            "A materialized view stores the query results physically, while a regular view does not.",
            "A materialized view cannot be updated, while a regular view can.",
            "A materialized view is created automatically by the database, while a regular view is not.",
            "A materialized view stores the query, while a regular view stores the results."
          ],
          "answer": "A materialized view stores the query results physically, while a regular view does not.",
          "explanation": "A materialized view is a snapshot of a query's result set that is physically stored in the database. In contrast, a regular view is a virtual table that re-executes the query whenever it is accessed."
        }
      ]
    },
    {
      "id": "encryption-security",
      "type": "topic",
      "title": "Encryption and Security",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "encryption-security-1",
          "question": "What is hashing in the context of data security?",
          "options": [
            "The process of converting plaintext data into a fixed-size string of characters.",
            "A method of encrypting data with a public key.",
            "A technique used to verify the integrity of data.",
            "A way to store passwords securely."
          ],
          "answer": "The process of converting plaintext data into a fixed-size string of characters.",
          "explanation": "Hashing transforms data into a fixed-length string, making it difficult to reverse-engineer the original data."
        },
        {
          "id": "encryption-security-2",
          "question": "What is the purpose of 'salting' in password hashing?",
          "options": [
            "To add a random value to the password before hashing it.",
            "To encrypt the password with a private key.",
            "To create a checksum of the password.",
            "To make the password longer."
          ],
          "answer": "To add a random value to the password before hashing it.",
          "explanation": "Salting adds a unique random value to each password, making it more resistant to rainbow table attacks."
        },
        {
          "id": "encryption-security-3",
          "question": "What is a checksum?",
          "options": [
            "A technique to secure data using encryption.",
            "A value used to verify the integrity of data.",
            "A method of encoding data for storage.",
            "An algorithm to generate random values."
          ],
          "answer": "A value used to verify the integrity of data.",
          "explanation": "A checksum is a computed value that helps to detect errors in data during transmission or storage."
        },
        {
          "id": "encryption-security-4",
          "question": "What does end-to-end encryption (E2EE) ensure?",
          "options": [
            "Only the sender and recipient can read the messages.",
            "Messages are stored securely on a server.",
            "Encryption keys are shared publicly.",
            "Data is compressed before transmission."
          ],
          "answer": "Only the sender and recipient can read the messages.",
          "explanation": "E2EE ensures that data is encrypted on the sender's device and only decrypted on the recipient's device, preventing intermediaries from accessing it."
        },
        {
          "id": "encryption-security-5",
          "question": "What is the main feature of public/private key encryption?",
          "options": [
            "It uses a single key for both encryption and decryption.",
            "It uses two different keys for encryption and decryption.",
            "It does not require any keys.",
            "It is only used for symmetric encryption."
          ],
          "answer": "It uses two different keys for encryption and decryption.",
          "explanation": "Public/private key encryption uses a public key for encryption and a corresponding private key for decryption, enhancing security."
        },
        {
          "id": "encryption-security-6",
          "question": "What is symmetric encryption?",
          "options": [
            "A method where the same key is used for both encryption and decryption.",
            "A technique that uses two different keys.",
            "A form of encryption that does not require a key.",
            "A method of hashing data."
          ],
          "answer": "A method where the same key is used for both encryption and decryption.",
          "explanation": "In symmetric encryption, the same key must be kept secret and is used for both encrypting and decrypting the data."
        },
        {
          "id": "encryption-security-7",
          "question": "Which of the following algorithms is commonly used for hashing?",
          "options": [
            "AES",
            "RSA",
            "SHA-256",
            "Diffie-Hellman"
          ],
          "answer": "SHA-256",
          "explanation": "SHA-256 is a widely used hashing algorithm that produces a 256-bit hash value."
        },
        {
          "id": "encryption-security-8",
          "question": "What does the term 'key exchange' refer to?",
          "options": [
            "The process of swapping symmetric keys between parties.",
            "The method of securely sharing public keys.",
            "A protocol for sending encrypted messages.",
            "The generation of new keys for encryption."
          ],
          "answer": "The process of swapping symmetric keys between parties.",
          "explanation": "Key exchange refers to the methods used to securely share cryptographic keys, allowing encrypted communication."
        },
        {
          "id": "encryption-security-9",
          "question": "In which scenario would you use symmetric encryption?",
          "options": [
            "When you need to securely send a message to multiple recipients.",
            "When both the sender and receiver can securely share a key.",
            "When you need to encrypt data at rest.",
            "When you want to avoid key management complexities."
          ],
          "answer": "When both the sender and receiver can securely share a key.",
          "explanation": "Symmetric encryption is efficient when the same key is shared between parties that can securely exchange it."
        },
        {
          "id": "encryption-security-10",
          "question": "Which of the following is NOT a characteristic of hashing?",
          "options": [
            "Deterministic output.",
            "Reversible process.",
            "Fixed-size output.",
            "Collision-resistant."
          ],
          "answer": "Reversible process.",
          "explanation": "Hashing is a one-way function, meaning it cannot be reversed to obtain the original input."
        },
        {
          "id": "encryption-security-11",
          "question": "What is the primary purpose of using salts in password storage?",
          "options": [
            "To increase the length of the password.",
            "To create unique hashes for the same password.",
            "To improve hashing speed.",
            "To encrypt the password before storage."
          ],
          "answer": "To create unique hashes for the same password.",
          "explanation": "Salts ensure that even identical passwords have unique hashes, enhancing security against dictionary attacks."
        },
        {
          "id": "encryption-security-12",
          "question": "What is the primary risk of not using encryption for sensitive data?",
          "options": [
            "Data can be accessed without authorization.",
            "Data will be automatically deleted.",
            "Data will be corrupted.",
            "Data will be publicly visible."
          ],
          "answer": "Data can be accessed without authorization.",
          "explanation": "Without encryption, sensitive data is vulnerable to unauthorized access and potential data breaches."
        }
      ]
    },
    {
      "id": "database-design-theory",
      "type": "topic",
      "title": "Database Design Theory",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "design-theory-1",
          "question": "What is a weak entity in an Entity-Relationship (ER) diagram?",
          "options": [
            "An entity that does not have any attributes.",
            "An entity that cannot be uniquely identified by its own attributes.",
            "An entity that has a 1:1 relationship with another entity.",
            "An entity that does not participate in relationships."
          ],
          "answer": "An entity that cannot be uniquely identified by its own attributes.",
          "explanation": "A weak entity is an entity that cannot be uniquely identified by its own attributes alone. It relies on a foreign key (typically from a related entity) along with its own attributes to form a composite primary key."
        },
        {
          "id": "design-theory-2",
          "question": "Which of the following is true about a strong entity?",
          "options": [
            "It always has a composite primary key.",
            "It can be uniquely identified by its own attributes.",
            "It cannot exist without a relationship to another entity.",
            "It always participates in a 1:N relationship."
          ],
          "answer": "It can be uniquely identified by its own attributes.",
          "explanation": "A strong entity can be uniquely identified by its own attributes without requiring foreign key dependency from another entity."
        },
        {
          "id": "design-theory-3",
          "question": "How is a weak entity typically represented in an ER diagram?",
          "options": [
            "As a rectangle with a single line border.",
            "As a rectangle with a double line border.",
            "As an oval with a single line border.",
            "As a circle with a dotted line."
          ],
          "answer": "As a rectangle with a double line border.",
          "explanation": "In ER diagrams, weak entities are often represented by rectangles with double line borders to distinguish them from strong entities."
        },
        {
          "id": "design-theory-4",
          "question": "In a relationship between a weak entity and a strong entity, what is the minimum cardinality on the strong entity side?",
          "options": [
            "1",
            "0",
            "N",
            "It depends on the relationship type."
          ],
          "answer": "1",
          "explanation": "In a relationship between a weak entity and a strong entity, the minimum cardinality on the strong entity side is typically 1, since the weak entity depends on the strong entity for identification."
        },
        {
          "id": "design-theory-5",
          "question": "What is a composite attribute in database design?",
          "options": [
            "An attribute that stores multiple values for each entity.",
            "An attribute that can be broken down into smaller parts.",
            "An attribute that uniquely identifies an entity.",
            "An attribute that consists of two foreign keys."
          ],
          "answer": "An attribute that can be broken down into smaller parts.",
          "explanation": "A composite attribute is one that can be divided into smaller sub-attributes. For example, an address attribute could be split into street, city, state, and zip code."
        },
        {
          "id": "design-theory-6",
          "question": "Which of the following is an identifying relationship?",
          "options": [
            "A relationship where a foreign key exists but is not part of the primary key.",
            "A relationship where the foreign key is part of the primary key of the weak entity.",
            "A 1:N relationship between two strong entities.",
            "A many-to-many relationship between any two entities."
          ],
          "answer": "A relationship where the foreign key is part of the primary key of the weak entity.",
          "explanation": "In an identifying relationship, the foreign key from the strong entity is part of the primary key of the weak entity, making it essential for the identification of the weak entity."
        },
        {
          "id": "design-theory-7",
          "question": "What is the main difference between a total participation and a partial participation in an ER diagram?",
          "options": [
            "Total participation means all instances of the entity must be involved in the relationship, while partial participation means only some instances are involved.",
            "Total participation requires a foreign key, while partial participation does not.",
            "Total participation occurs only in weak entities, while partial participation occurs only in strong entities.",
            "Total participation is always represented with a dashed line, while partial participation is represented with a solid line."
          ],
          "answer": "Total participation means all instances of the entity must be involved in the relationship, while partial participation means only some instances are involved.",
          "explanation": "Total participation means every instance of the entity must be involved in the relationship, whereas partial participation means that some instances of the entity are not necessarily involved in the relationship."
        },
        {
          "id": "design-theory-8",
          "question": "Which of the following is an example of a multivalued attribute?",
          "options": [
            "An employee's name.",
            "A customer's phone numbers.",
            "A product's price.",
            "An order's shipping address."
          ],
          "answer": "A customer's phone numbers.",
          "explanation": "A multivalued attribute can store more than one value for a single entity. In this case, a customer can have multiple phone numbers."
        },
        {
          "id": "design-theory-9",
          "question": "How is a many-to-many (M:N) relationship represented in a relational database?",
          "options": [
            "As a single table with two primary keys.",
            "By splitting the M:N relationship into two 1:N relationships using an associative entity.",
            "As a composite key within the same entity.",
            "Using a foreign key in one of the tables."
          ],
          "answer": "By splitting the M:N relationship into two 1:N relationships using an associative entity.",
          "explanation": "In relational databases, many-to-many relationships are typically broken down into two one-to-many relationships by introducing an associative (or junction) table."
        },
        {
          "id": "design-theory-10",
          "question": "What is an entity’s primary key composed of in a one-to-one (1:1) relationship?",
          "options": [
            "A composite key consisting of foreign keys from both entities.",
            "The primary key of either entity can be used.",
            "A new attribute that is unique across both entities.",
            "A combination of foreign keys from other related entities."
          ],
          "answer": "The primary key of either entity can be used.",
          "explanation": "In a one-to-one relationship, either entity’s primary key can be used as the foreign key in the other entity because there is a direct one-to-one correspondence between the instances of the two entities."
        }
      ]
    },
    {
      "id": "sql-optimization-performance",
      "type": "topic",
      "title": "SQL Optimization & Performance",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-indexing-1",
          "question": "What is the purpose of using indexes in a SQL database?",
          "options": [
            "To store duplicate records more efficiently",
            "To speed up data retrieval operations",
            "To encrypt sensitive data",
            "To manage relationships between tables"
          ],
          "answer": "To speed up data retrieval operations",
          "explanation": "Indexes are used to speed up queries by providing a fast way to look up records without scanning the entire table."
        },
        {
          "id": "sql-indexing-2",
          "question": "Which of the following types of queries benefit the most from using an index?",
          "options": [
            "Queries that perform frequent updates on a table",
            "Queries that search for data based on specific column values",
            "Queries that create new tables",
            "Queries that aggregate data using GROUP BY"
          ],
          "answer": "Queries that search for data based on specific column values",
          "explanation": "Indexes are most useful for queries that frequently search for data based on specific column values, as they reduce the amount of data scanned during a search."
        },
        {
          "id": "sql-indexing-3",
          "question": "What is a clustered index in SQL?",
          "options": [
            "An index that stores data in a non-sequential order",
            "An index where the physical order of rows in the table matches the order of the index",
            "An index that stores duplicate rows more efficiently",
            "An index that can be applied to multiple columns"
          ],
          "answer": "An index where the physical order of rows in the table matches the order of the index",
          "explanation": "A clustered index sorts and stores the data rows in the table based on the index key. The table can have only one clustered index, as the data rows themselves can only be stored in one order."
        },
        {
          "id": "sql-indexing-4",
          "question": "What is a non-clustered index in SQL?",
          "options": [
            "An index that stores a separate copy of the data with pointers to the table rows",
            "An index that automatically updates when data is inserted",
            "An index that allows duplicate values in a column",
            "An index that can only be created on unique columns"
          ],
          "answer": "An index that stores a separate copy of the data with pointers to the table rows",
          "explanation": "A non-clustered index stores a separate copy of the indexed data and includes pointers to the actual rows in the table. Multiple non-clustered indexes can exist on a table."
        },
        {
          "id": "sql-indexing-5",
          "question": "What is a composite index?",
          "options": [
            "An index created on more than one column",
            "An index that combines clustered and non-clustered indexes",
            "An index created automatically by the database system",
            "An index that allows duplicate values"
          ],
          "answer": "An index created on more than one column",
          "explanation": "A composite index is created on two or more columns of a table and is useful when queries frequently filter on a combination of those columns."
        },
        {
          "id": "sql-indexing-6",
          "question": "What is the downside of using too many indexes on a table?",
          "options": [
            "Indexes can lead to slower data retrieval operations",
            "Indexes can cause tables to become corrupted",
            "Indexes can negatively impact the performance of INSERT, UPDATE, and DELETE operations",
            "Indexes prevent you from creating foreign key constraints"
          ],
          "answer": "Indexes can negatively impact the performance of INSERT, UPDATE, and DELETE operations",
          "explanation": "Although indexes improve query performance for data retrieval, they can slow down INSERT, UPDATE, and DELETE operations because the database has to update the indexes whenever data changes."
        },
        {
          "id": "sql-indexing-7",
          "question": "What is the difference between a unique index and a regular index?",
          "options": [
            "A unique index allows duplicate values, while a regular index does not",
            "A unique index does not allow duplicate values, while a regular index does",
            "A unique index is faster than a regular index",
            "A unique index is always clustered, while a regular index is not"
          ],
          "answer": "A unique index does not allow duplicate values, while a regular index does",
          "explanation": "A unique index ensures that all values in the indexed column(s) are unique, whereas a regular index allows duplicate values."
        },
        {
          "id": "sql-indexing-8",
          "question": "When should you avoid using indexes?",
          "options": [
            "On columns that are frequently queried",
            "On columns that have low cardinality (few unique values)",
            "On columns that are part of foreign key constraints",
            "On tables that rarely change"
          ],
          "answer": "On columns that have low cardinality (few unique values)",
          "explanation": "Indexes are less useful on columns with low cardinality (few unique values), such as columns with boolean values or status flags, because they provide little benefit over scanning the entire table."
        }
      ]
    },
    {
      "id": "sql-subqueries",
      "type": "new-topic",
      "title": "Subqueries I",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-subqueries-1",
          "question": "Write a SQL query to find the customer who has placed the largest number of orders. Use the 'customers' and 'orders' tables.",
          "initialData": [
            "CREATE TABLE customers (customer_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE orders (order_id INTEGER PRIMARY KEY, customer_id INTEGER, order_total DECIMAL);",
            "INSERT INTO customers (customer_id, name) VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');",
            "INSERT INTO orders (order_id, customer_id, order_total) VALUES (1, 1, 100), (2, 1, 50), (3, 2, 200), (4, 3, 75);"
          ],
          "expectedResult": "SELECT name FROM customers WHERE customer_id = (SELECT customer_id FROM orders GROUP BY customer_id ORDER BY COUNT(order_id) DESC LIMIT 1);",
          "explanation": "This query uses a subquery to count the number of orders per customer and return the customer who has placed the most orders."
        },
        {
          "id": "sql-subqueries-2",
          "question": "Write a SQL query to find the author who has written the longest book. Use the 'authors' and 'books' tables.",
          "initialData": [
            "CREATE TABLE authors (author_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE books (book_id INTEGER PRIMARY KEY, author_id INTEGER, pages INTEGER);",
            "INSERT INTO authors (author_id, name) VALUES (1, 'George Orwell'), (2, 'J.K. Rowling'), (3, 'J.R.R. Tolkien');",
            "INSERT INTO books (book_id, author_id, pages) VALUES (1, 1, 326), (2, 2, 870), (3, 3, 1178);"
          ],
          "expectedResult": "SELECT name FROM authors WHERE author_id = (SELECT author_id FROM books ORDER BY pages DESC LIMIT 1);",
          "explanation": "This query uses a subquery to find the book with the highest number of pages and then retrieves the corresponding author."
        },
        {
          "id": "sql-subqueries-3",
          "question": "Write a SQL query to find the event with the highest attendance, along with the city where it was held. Use the 'events' and 'cities' tables.",
          "initialData": [
            "CREATE TABLE events (event_id INTEGER PRIMARY KEY, name TEXT, city_id INTEGER, attendance INTEGER);",
            "CREATE TABLE cities (city_id INTEGER PRIMARY KEY, city_name TEXT);",
            "INSERT INTO events (event_id, name, city_id, attendance) VALUES (1, 'Music Festival', 1, 5000), (2, 'Tech Conference', 2, 15000), (3, 'Art Expo', 3, 3000);",
            "INSERT INTO cities (city_id, city_name) VALUES (1, 'New York'), (2, 'San Francisco'), (3, 'Los Angeles');"
          ],
          "expectedResult": "SELECT name, city_name FROM events JOIN cities ON events.city_id = cities.city_id WHERE attendance = (SELECT MAX(attendance) FROM events);",
          "explanation": "This query finds the event with the highest attendance using a subquery and retrieves the event name along with the city where it was held."
        },
        {
          "id": "sql-subqueries-4",
          "question": "Write a SQL query to find the student with the highest average test score across all their tests. Use the 'students' and 'test_scores' tables.",
          "initialData": [
            "CREATE TABLE students (student_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE test_scores (test_id INTEGER PRIMARY KEY, student_id INTEGER, score INTEGER);",
            "INSERT INTO students (student_id, name) VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');",
            "INSERT INTO test_scores (test_id, student_id, score) VALUES (1, 1, 85), (2, 1, 90), (3, 2, 78), (4, 3, 92), (5, 3, 88);"
          ],
          "expectedResult": "SELECT name FROM students WHERE student_id = (SELECT student_id FROM test_scores GROUP BY student_id ORDER BY AVG(score) DESC LIMIT 1);",
          "explanation": "This query calculates the average test score for each student and uses a subquery to find the student with the highest average."
        }
      ]
    },
    {
      "id": "sql-group-by",
      "type": "topic",
      "title": "GROUP BY",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-group-by-1",
          "question": "Which of the following SQL statements correctly groups the 'products' table by category and counts the total number of products in each category?",
          "options": [
            "SELECT category, COUNT(*) FROM products GROUP BY category;",
            "SELECT category, COUNT(*) FROM products ORDER BY category;",
            "SELECT COUNT(*) FROM products GROUP BY category;",
            "SELECT category FROM products GROUP BY category;"
          ],
          "answer": "SELECT category, COUNT(*) FROM products GROUP BY category;",
          "explanation": "This statement correctly groups the 'products' table by category and counts the total number of products using COUNT(*)."
        },
        {
          "id": "sql-group-by-2",
          "question": "Write a SQL query to group the planets by their types and count how many moons they have in total. Use the 'planets' and 'moons' tables.",
          "initialData": [
            "CREATE TABLE planets (planet_id INTEGER PRIMARY KEY, name TEXT, type TEXT);",
            "CREATE TABLE moons (moon_id INTEGER PRIMARY KEY, planet_id INTEGER, name TEXT);",
            "INSERT INTO planets (planet_id, name, type) VALUES (1, 'Earth', 'Terrestrial'), (2, 'Jupiter', 'Gas Giant'), (3, 'Mars', 'Terrestrial');",
            "INSERT INTO moons (moon_id, planet_id, name) VALUES (1, 1, 'Moon'), (2, 2, 'Europa'), (3, 2, 'Ganymede'), (4, 3, 'Phobos'), (5, 3, 'Deimos');"
          ],
          "expectedResult": "SELECT planets.type, COUNT(moons.moon_id) as moon_count FROM planets LEFT JOIN moons ON planets.planet_id = moons.planet_id GROUP BY planets.type;",
          "explanation": "This query groups the planets by type and counts the total number of moons for each type using a LEFT JOIN to ensure all planet types are represented."
        },
        {
          "id": "sql-group-by-3",
          "question": "Write a SQL query to find the total number of unique ingredients used by each type of dish. Use the 'dishes' and 'ingredients' tables.",
          "initialData": [
            "CREATE TABLE dishes (dish_id INTEGER PRIMARY KEY, name TEXT, type TEXT);",
            "CREATE TABLE ingredients (ingredient_id INTEGER PRIMARY KEY, dish_id INTEGER, name TEXT);",
            "INSERT INTO dishes (dish_id, name, type) VALUES (1, 'Pizza', 'Italian'), (2, 'Sushi', 'Japanese'), (3, 'Lasagna', 'Italian');",
            "INSERT INTO ingredients (ingredient_id, dish_id, name) VALUES (1, 1, 'Cheese'), (2, 1, 'Tomato'), (3, 2, 'Rice'), (4, 3, 'Cheese'), (5, 3, 'Pasta');"
          ],
          "expectedResult": "SELECT dishes.type, COUNT(DISTINCT ingredients.name) as unique_ingredients FROM dishes INNER JOIN ingredients ON dishes.dish_id = ingredients.dish_id GROUP BY dishes.type;",
          "explanation": "This query uses an INNER JOIN and GROUP BY to find the total number of unique ingredients used in each type of dish, using COUNT with DISTINCT to ensure ingredients are only counted once."
        },
        {
          "id": "sql-group-by-4",
          "question": "Write a SQL query to find the most popular genre of book by counting how many times each genre is borrowed from a library. Use the 'books' and 'borrows' tables.",
          "initialData": [
            "CREATE TABLE books (book_id INTEGER PRIMARY KEY, title TEXT, genre TEXT);",
            "CREATE TABLE borrows (borrow_id INTEGER PRIMARY KEY, book_id INTEGER, borrow_date DATE);",
            "INSERT INTO books (book_id, title, genre) VALUES (1, 'Dune', 'Sci-Fi'), (2, '1984', 'Dystopian'), (3, 'The Hobbit', 'Fantasy');",
            "INSERT INTO borrows (borrow_id, book_id, borrow_date) VALUES (1, 1, '2024-01-01'), (2, 2, '2024-02-15'), (3, 1, '2024-03-10'), (4, 3, '2024-04-12');"
          ],
          "expectedResult": "SELECT books.genre, COUNT(borrows.borrow_id) as borrow_count FROM books LEFT JOIN borrows ON books.book_id = borrows.book_id GROUP BY books.genre;",
          "explanation": "This query groups the books by genre and counts how many times books from each genre have been borrowed, even if some genres have no borrows."
        }
      ]
    },
    {
      "id": "sql-having",
      "type": "new-topic",
      "title": "HAVING",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-having-1",
          "question": "Write a SQL query to find the cities where the average temperature in the last year exceeded 80°F. Use the 'cities' and 'weather' tables.",
          "initialData": [
            "CREATE TABLE cities (city_id INTEGER PRIMARY KEY, city_name TEXT);",
            "CREATE TABLE weather (weather_id INTEGER PRIMARY KEY, city_id INTEGER, temperature DECIMAL, date DATE);",
            "INSERT INTO cities (city_id, city_name) VALUES (1, 'Phoenix'), (2, 'Seattle'), (3, 'Miami');",
            "INSERT INTO weather (weather_id, city_id, temperature, date) VALUES (1, 1, 90, '2024-06-01'), (2, 1, 95, '2024-07-01'), (3, 2, 70, '2024-06-01'), (4, 2, 65, '2024-07-01'), (5, 3, 85, '2024-06-01'), (6, 3, 88, '2024-07-01');"
          ],
          "expectedResult": "SELECT city_name FROM cities JOIN weather ON cities.city_id = weather.city_id GROUP BY city_name HAVING AVG(temperature) > 80;",
          "explanation": "This query groups the cities by name and uses the `HAVING` clause to filter out cities with an average temperature below 80°F."
        },
        {
          "id": "sql-having-2",
          "question": "Write a SQL query to find the authors who have written more than two books. Use the 'authors' and 'books' tables.",
          "initialData": [
            "CREATE TABLE authors (author_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE books (book_id INTEGER PRIMARY KEY, author_id INTEGER, title TEXT);",
            "INSERT INTO authors (author_id, name) VALUES (1, 'George Orwell'), (2, 'J.K. Rowling'), (3, 'Isaac Asimov');",
            "INSERT INTO books (book_id, author_id, title) VALUES (1, 1, '1984'), (2, 1, 'Animal Farm'), (3, 2, 'Harry Potter and the Sorcerers Stone'), (4, 2, 'Harry Potter and the Chamber of Secrets'), (5, 2, 'Harry Potter and the Prisoner of Azkaban'), (6, 3, 'Foundation');"
          ],
          "expectedResult": "SELECT name FROM authors JOIN books ON authors.author_id = books.author_id GROUP BY authors.name HAVING COUNT(books.book_id) > 2;",
          "explanation": "This query groups authors by name and uses the `HAVING` clause to find authors who have written more than two books."
        },
        {
          "id": "sql-having-3",
          "question": "Write a SQL query to find the restaurants where the average review rating is below 3 stars. Use the 'restaurants' and 'reviews' tables.",
          "initialData": [
            "CREATE TABLE restaurants (restaurant_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE reviews (review_id INTEGER PRIMARY KEY, restaurant_id INTEGER, rating DECIMAL);",
            "INSERT INTO restaurants (restaurant_id, name) VALUES (1, 'Burger Town'), (2, 'Sushi Palace'), (3, 'Pasta Heaven');",
            "INSERT INTO reviews (review_id, restaurant_id, rating) VALUES (1, 1, 2.5), (2, 1, 3), (3, 2, 4.5), (4, 2, 4.2), (5, 3, 1.8), (6, 3, 2.1);"
          ],
          "expectedResult": "SELECT name FROM restaurants JOIN reviews ON restaurants.restaurant_id = reviews.restaurant_id GROUP BY restaurants.name HAVING AVG(reviews.rating) < 3;",
          "explanation": "This query uses `HAVING` to find restaurants with an average review rating below 3 stars by grouping the results by restaurant."
        },
        {
          "id": "sql-having-4",
          "question": "Write a SQL query to find the sports teams that have won more than 3 championships. Use the 'teams' and 'championships' tables.",
          "initialData": [
            "CREATE TABLE teams (team_id INTEGER PRIMARY KEY, team_name TEXT);",
            "CREATE TABLE championships (championship_id INTEGER PRIMARY KEY, team_id INTEGER, year INTEGER);",
            "INSERT INTO teams (team_id, team_name) VALUES (1, 'Lions'), (2, 'Tigers'), (3, 'Bears');",
            "INSERT INTO championships (championship_id, team_id, year) VALUES (1, 1, 2020), (2, 1, 2018), (3, 2, 2019), (4, 2, 2021), (5, 2, 2022), (6, 3, 2017);"
          ],
          "expectedResult": "SELECT team_name FROM teams JOIN championships ON teams.team_id = championships.team_id GROUP BY teams.team_name HAVING COUNT(championships.championship_id) > 3;",
          "explanation": "This query uses `HAVING` to find teams that have won more than 3 championships by grouping the teams and counting their championships."
        }
      ]
    },
    {
      "id": "sql-composite-primary-keys",
      "type": "topic",
      "title": "Composite Primary Keys",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-cpk-1",
          "question": "What is a composite primary key?",
          "options": [
            "A primary key that consists of more than one column.",
            "A foreign key that references multiple tables.",
            "A key that allows NULL values.",
            "A key that is automatically generated by the database."
          ],
          "answer": "A primary key that consists of more than one column.",
          "explanation": "A composite primary key is made up of two or more columns that together form a unique identifier for each record in a table."
        },
        {
          "id": "sql-cpk-2",
          "question": "Which of the following best describes when you should use a composite primary key?",
          "options": [
            "When no single column can uniquely identify each record in the table.",
            "When a table has more than three columns.",
            "When the table has only foreign key relationships.",
            "When a table has no primary key."
          ],
          "answer": "When no single column can uniquely identify each record in the table.",
          "explanation": "A composite primary key is useful when no single column provides unique identification but a combination of multiple columns does."
        },
        {
          "id": "sql-cpk-3",
          "question": "Write a SQL query to create a 'book_loans' table with a composite primary key consisting of 'book_id' and 'borrower_id'.",
          "initialData": [],
          "expectedResult": "CREATE TABLE book_loans (book_id INTEGER, borrower_id INTEGER, loan_date DATE, PRIMARY KEY (book_id, borrower_id));",
          "explanation": "This query creates a table where the combination of 'book_id' and 'borrower_id' forms a unique identifier for each record, ensuring that the same book cannot be borrowed by the same person more than once at the same time."
        },
        {
          "id": "sql-cpk-4",
          "question": "Which of the following SQL statements correctly defines a composite primary key?",
          "options": [
            "PRIMARY KEY (column1, column2)",
            "PRIMARY KEY (column1), PRIMARY KEY (column2)",
            "PRIMARY KEY (column1 AND column2)",
            "PRIMARY KEY (column1 OR column2)"
          ],
          "answer": "PRIMARY KEY (column1, column2)",
          "explanation": "The correct syntax for defining a composite primary key is 'PRIMARY KEY (column1, column2)', which ensures that the combination of column1 and column2 is unique."
        },
        {
          "id": "sql-cpk-5",
          "question": "Write a SQL query to create a 'student_courses' table where a student can enroll in multiple courses but cannot enroll in the same course more than once. Use 'student_id' and 'course_id' as the composite primary key.",
          "initialData": [],
          "expectedResult": "CREATE TABLE student_courses (student_id INTEGER, course_id INTEGER, enrollment_date DATE, PRIMARY KEY (student_id, course_id));",
          "explanation": "This query defines 'student_id' and 'course_id' as a composite primary key, ensuring that a student cannot be enrolled in the same course more than once."
        },
        {
          "id": "sql-cpk-6",
          "question": "Why is a composite primary key beneficial in many-to-many relationships?",
          "options": [
            "It helps uniquely identify each relationship between entities.",
            "It reduces the number of columns needed in a table.",
            "It ensures that only one entity is referenced.",
            "It automatically generates foreign key constraints."
          ],
          "answer": "It helps uniquely identify each relationship between entities.",
          "explanation": "In many-to-many relationships, a composite primary key allows you to uniquely identify each pair of related entities, which is essential for linking records between the two tables."
        },
        {
          "id": "sql-cpk-7",
          "question": "Write a SQL query to find all loans in the 'book_loans' table where the same 'book_id' was borrowed by more than one 'borrower_id' on the same 'loan_date'.",
          "initialData": [
            "CREATE TABLE book_loans (book_id INTEGER, borrower_id INTEGER, loan_date DATE, PRIMARY KEY (book_id, borrower_id));",
            "INSERT INTO book_loans (book_id, borrower_id, loan_date) VALUES (1, 101, '2024-01-01'), (1, 102, '2024-01-01'), (2, 103, '2024-02-01');"
          ],
          "expectedResult": "SELECT book_id, loan_date, COUNT(borrower_id) as borrower_count FROM book_loans GROUP BY book_id, loan_date HAVING COUNT(borrower_id) > 1;",
          "explanation": "This query groups the results by 'book_id' and 'loan_date', then uses `HAVING` to filter out groups where more than one borrower borrowed the same book on the same date."
        }
      ]
    },
    {
      "id": "sql-like",
      "type": "new-topic",
      "title": "LIKE and Pattern Matching",
      "difficulty": "Easy",
      "questions": [
        {
          "id": "sql-like-1",
          "question": "Which of the following is a wildcard used in SQL for matching any sequence of characters?",
          "options": [
            "%",
            "_",
            "#",
            "$"
          ],
          "answer": "%",
          "explanation": "The '%' wildcard in SQL is used to match any sequence of characters (zero or more) in a string. For example, 'A%' would match any string that starts with 'A'."
        },
        {
          "id": "sql-like-2",
          "question": "Which SQL wildcard is used to match exactly one character?",
          "options": [
            "_",
            "%",
            "*",
            "?"
          ],
          "answer": "_",
          "explanation": "The '_' wildcard in SQL matches exactly one character. For example, 'A_' would match any two-character string that starts with 'A', like 'An' or 'A1'."
        },
        {
          "id": "sql-like-3",
          "question": "Write a SQL query to find all users whose names start with 'J'. Use the 'users' table.",
          "initialData": [
            "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);",
            "INSERT INTO users (name) VALUES ('John'), ('Jane'), ('Alice'), ('Jill');"
          ],
          "expectedResult": "SELECT * FROM users WHERE name LIKE 'J%';",
          "explanation": "This query uses the 'LIKE' operator with the '%' wildcard to match any names that start with 'J'."
        },
        {
          "id": "sql-like-4",
          "question": "Write a SQL query to find all books whose titles have exactly five characters. Use the 'books' table.",
          "initialData": [
            "CREATE TABLE books (book_id INTEGER PRIMARY KEY, title TEXT);",
            "INSERT INTO books (title) VALUES ('Dune'), ('It'), ('1984'), ('Brave'), ('Fahrenheit');"
          ],
          "expectedResult": "SELECT * FROM books WHERE title LIKE '_____';",
          "explanation": "This query uses the 'LIKE' operator with the '_' wildcard repeated five times to match titles with exactly five characters."
        },
        {
          "id": "sql-like-5",
          "question": "Which of the following queries finds all emails ending with '.com'?",
          "options": [
            "SELECT * FROM users WHERE email LIKE '%.com';",
            "SELECT * FROM users WHERE email LIKE '%com';",
            "SELECT * FROM users WHERE email LIKE '_.com';",
            "SELECT * FROM users WHERE email LIKE '%@%.com';"
          ],
          "answer": "SELECT * FROM users WHERE email LIKE '%.com';",
          "explanation": "The query 'SELECT * FROM users WHERE email LIKE '%.com';' finds all emails ending with '.com', where '%' can match any characters before the '.com'."
        },
        {
          "id": "sql-like-6",
          "question": "Write a SQL query to find all products where the third character in the product name is 'X'. Use the 'products' table.",
          "initialData": [
            "CREATE TABLE products (product_id INTEGER PRIMARY KEY, name TEXT);",
            "INSERT INTO products (name) VALUES ('AXE'), ('BOX'), ('PIXEL'), ('MAXIMUS');"
          ],
          "expectedResult": "SELECT * FROM products WHERE name LIKE '__X%';",
          "explanation": "This query uses two underscores '__' to match the first two characters, then 'X' for the third character, followed by '%' to match any sequence of characters after."
        },
        {
          "id": "sql-like-7",
          "question": "Write a SQL query to find all songs whose title contains the word 'Love' (case-insensitive). Use the 'songs' table.",
          "initialData": [
            "CREATE TABLE songs (song_id INTEGER PRIMARY KEY, title TEXT);",
            "INSERT INTO songs (title) VALUES ('Endless Love'), ('Crazy In Love'), ('Tainted Love'), ('All You Need Is Love');"
          ],
          "expectedResult": "SELECT * FROM songs WHERE LOWER(title) LIKE '%love%';",
          "explanation": "This query uses the 'LOWER()' function to make the search case-insensitive, and '%love%' matches any titles containing 'love'."
        },
        {
          "id": "sql-like-8",
          "question": "Which of the following SQL statements will find all usernames that end with the letter 'e'?",
          "options": [
            "SELECT * FROM users WHERE username LIKE '%e';",
            "SELECT * FROM users WHERE username LIKE '_e%';",
            "SELECT * FROM users WHERE username LIKE 'e%';",
            "SELECT * FROM users WHERE username LIKE '_e';"
          ],
          "answer": "SELECT * FROM users WHERE username LIKE '%e';",
          "explanation": "The query 'SELECT * FROM users WHERE username LIKE '%e';' will return all usernames that end with the letter 'e', where '%' matches any characters before the 'e'."
        }
      ]
    },
    {
      "id": "sql-left-joins-with-null",
      "type": "topic",
      "title": "LEFT JOINs with NULL",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-left-join-null-4",
          "question": "Which function can be used to replace NULL values with a specific value in SQL?",
          "options": [
            "COALESCE",
            "ISNULL",
            "NVL",
            "IFNULL"
          ],
          "answer": "COALESCE",
          "explanation": "COALESCE is used to return the first non-NULL value in a list of arguments. It's often used to replace NULL values with a specified value in SQL."
        },
        {
          "id": "sql-left-join-null-1",
          "question": "Write a SQL query to find all customers and the orders they have placed. Include customers who have not placed any orders, and display 'No orders' for customers with no orders. Use the 'customers' and 'orders' tables.",
          "initialData": [
            "CREATE TABLE customers (customer_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE orders (order_id INTEGER PRIMARY KEY, customer_id INTEGER, order_details TEXT);",
            "INSERT INTO customers (customer_id, name) VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');",
            "INSERT INTO orders (order_id, customer_id, order_details) VALUES (1, 1, 'Laptop'), (2, 1, 'Mouse'), (3, 3, 'Keyboard');"
          ],
          "expectedResult": "SELECT customers.name, COALESCE(orders.order_details, 'No orders') as order_details FROM customers LEFT JOIN orders ON customers.customer_id = orders.customer_id;",
          "explanation": "This query uses a LEFT JOIN to include all customers, even those without orders. The COALESCE function replaces NULL order details with 'No orders' for customers who haven’t placed any orders."
        },
        {
          "id": "sql-left-join-null-2",
          "question": "Write a SQL query to list all employees and their respective departments. Include employees who are not assigned to any department, and show 'No department' where appropriate. Use the 'employees' and 'departments' tables.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, department_id INTEGER);",
            "CREATE TABLE departments (department_id INTEGER PRIMARY KEY, department_name TEXT);",
            "INSERT INTO employees (employee_id, name, department_id) VALUES (1, 'John', 101), (2, 'Jane', NULL), (3, 'Emily', 102);",
            "INSERT INTO departments (department_id, department_name) VALUES (101, 'HR'), (102, 'Engineering');"
          ],
          "expectedResult": "SELECT employees.name, COALESCE(departments.department_name, 'No department') as department FROM employees LEFT JOIN departments ON employees.department_id = departments.department_id;",
          "explanation": "This query uses a LEFT JOIN to include all employees, even those without an assigned department. The COALESCE function fills in 'No department' where employees don’t have a department."
        },
        {
          "id": "sql-left-join-null-3",
          "question": "Which SQL keyword is used to include all records from the left table and matching records from the right table, with NULL values in place of missing matches?",
          "options": [
            "LEFT JOIN",
            "INNER JOIN",
            "RIGHT JOIN",
            "FULL OUTER JOIN"
          ],
          "answer": "LEFT JOIN",
          "explanation": "A LEFT JOIN includes all records from the left table and matching records from the right table, filling in NULLs where no matches are found."
        },
        {
          "id": "sql-left-join-null-5",
          "question": "Write a SQL query to list all products and their corresponding supplier names. Include products that have no supplier and show 'No supplier' for such products. Use the 'products' and 'suppliers' tables.",
          "initialData": [
            "CREATE TABLE products (product_id INTEGER PRIMARY KEY, product_name TEXT, supplier_id INTEGER);",
            "CREATE TABLE suppliers (supplier_id INTEGER PRIMARY KEY, supplier_name TEXT);",
            "INSERT INTO products (product_id, product_name, supplier_id) VALUES (1, 'Laptop', 201), (2, 'Mouse', NULL), (3, 'Keyboard', 202);",
            "INSERT INTO suppliers (supplier_id, supplier_name) VALUES (201, 'TechCorp'), (202, 'GadgetPro');"
          ],
          "expectedResult": "SELECT products.product_name, COALESCE(suppliers.supplier_name, 'No supplier') as supplier FROM products LEFT JOIN suppliers ON products.supplier_id = suppliers.supplier_id;",
          "explanation": "This query uses a LEFT JOIN to include all products, even those without a supplier. The COALESCE function fills in 'No supplier' where products are missing a supplier."
        },
        {
          "id": "sql-left-join-null-6",
          "question": "Write a SQL query to display all courses and the students enrolled in them, including courses with no students enrolled. Show 'No students' for such courses. Use the 'courses' and 'enrollments' tables.",
          "initialData": [
            "CREATE TABLE courses (course_id INTEGER PRIMARY KEY, course_name TEXT);",
            "CREATE TABLE enrollments (enrollment_id INTEGER PRIMARY KEY, course_id INTEGER, student_name TEXT);",
            "INSERT INTO courses (course_id, course_name) VALUES (1, 'Math'), (2, 'Science'), (3, 'History');",
            "INSERT INTO enrollments (enrollment_id, course_id, student_name) VALUES (1, 1, 'Alice'), (2, 1, 'Bob');"
          ],
          "expectedResult": "SELECT courses.course_name, COALESCE(enrollments.student_name, 'No students') as student FROM courses LEFT JOIN enrollments ON courses.course_id = enrollments.course_id;",
          "explanation": "This query uses a LEFT JOIN to display all courses, even those without any students enrolled. The COALESCE function is used to replace NULL values with 'No students' where appropriate."
        }
      ]
    },
    {
      "id": "sql-foreign-keys",
      "type": "topic",
      "title": "Foreign Keys",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-fk-1",
          "question": "What is a foreign key in SQL?",
          "options": [
            "A field in one table that uniquely identifies a row of another table.",
            "A field that must contain unique values in the same table.",
            "A key that automatically generates values for a column.",
            "A column that can store multiple types of data."
          ],
          "answer": "A field in one table that uniquely identifies a row of another table.",
          "explanation": "A foreign key is a field in one table that references the primary key of another table, creating a relationship between the two tables."
        },
        {
          "id": "sql-fk-2",
          "question": "Which of the following SQL statements correctly defines a foreign key in a 'orders' table that references the 'customers' table?",
          "options": [
            "FOREIGN KEY (customer_id) REFERENCES customers(id)",
            "PRIMARY KEY (customer_id) REFERENCES customers(id)",
            "UNIQUE KEY (customer_id) REFERENCES customers(id)",
            "FOREIGN KEY (customer_id) REFERENCES orders(id)"
          ],
          "answer": "FOREIGN KEY (customer_id) REFERENCES customers(id)",
          "explanation": "The correct syntax to define a foreign key is 'FOREIGN KEY (column) REFERENCES other_table(column)', where the foreign key references the primary key in another table."
        },
        {
          "id": "sql-fk-3",
          "question": "Write a SQL query to create a 'orders' table where the 'customer_id' is a foreign key that references the 'id' column in the 'customers' table.",
          "initialData": [],
          "expectedResult": "CREATE TABLE orders (order_id INTEGER PRIMARY KEY, customer_id INTEGER, order_details TEXT, FOREIGN KEY (customer_id) REFERENCES customers(id));",
          "explanation": "This query creates a table with a foreign key constraint on the 'customer_id' column, which references the 'id' column of the 'customers' table, enforcing the relationship between the two tables."
        },
        {
          "id": "sql-fk-4",
          "question": "What is the purpose of a foreign key in a database?",
          "options": [
            "To enforce referential integrity between two tables.",
            "To automatically generate unique values for a column.",
            "To ensure all values in a column are unique.",
            "To group rows in a table based on common values."
          ],
          "answer": "To enforce referential integrity between two tables.",
          "explanation": "A foreign key enforces referential integrity, ensuring that a value in one table corresponds to an existing value in another table, maintaining the relationship between them."
        },
        {
          "id": "sql-fk-5",
          "question": "Write a SQL query to create a 'students' table and a 'courses' table, where the 'course_id' in the 'students' table is a foreign key referencing the 'id' column in the 'courses' table.",
          "initialData": [],
          "expectedResult": "CREATE TABLE courses (id INTEGER PRIMARY KEY, course_name TEXT); CREATE TABLE students (student_id INTEGER PRIMARY KEY, student_name TEXT, course_id INTEGER, FOREIGN KEY (course_id) REFERENCES courses(id));",
          "explanation": "This query creates a relationship between the 'students' and 'courses' tables by defining 'course_id' in the 'students' table as a foreign key that references the 'id' column of the 'courses' table."
        },
        {
          "id": "sql-fk-6",
          "question": "Which of the following describes the ON DELETE CASCADE option in a foreign key constraint?",
          "options": [
            "It deletes all records in the referencing table when the referenced record is deleted.",
            "It deletes all records in the referenced table when the referencing record is deleted.",
            "It prevents deletion of the referenced record if there are matching records in the referencing table.",
            "It updates all records in the referencing table when the referenced record is updated."
          ],
          "answer": "It deletes all records in the referencing table when the referenced record is deleted.",
          "explanation": "ON DELETE CASCADE ensures that when a referenced record in the parent table is deleted, all related records in the referencing (child) table are automatically deleted."
        },
        {
          "id": "sql-fk-7",
          "question": "Write a SQL query to create a 'books' table and a 'authors' table, where deleting an author will automatically delete all books written by that author. Use the ON DELETE CASCADE option.",
          "initialData": [],
          "expectedResult": "CREATE TABLE authors (author_id INTEGER PRIMARY KEY, name TEXT); CREATE TABLE books (book_id INTEGER PRIMARY KEY, title TEXT, author_id INTEGER, FOREIGN KEY (author_id) REFERENCES authors(author_id) ON DELETE CASCADE);",
          "explanation": "This query creates a relationship between 'books' and 'authors' where, if an author is deleted, all books written by that author are also deleted due to the ON DELETE CASCADE option."
        },
        {
          "id": "sql-fk-8",
          "question": "What happens if you try to insert a value into a foreign key column that does not exist in the referenced table?",
          "options": [
            "The insert will fail due to a foreign key constraint violation.",
            "The insert will succeed and the value will be inserted as NULL.",
            "The insert will succeed and a default value will be used.",
            "The insert will succeed if the value is unique."
          ],
          "answer": "The insert will fail due to a foreign key constraint violation.",
          "explanation": "When inserting a value into a foreign key column, the value must exist in the referenced table. If it does not, the operation fails due to a foreign key constraint violation."
        }
      ]
    },
    {
      "id": "sql-between",
      "type": "topic",
      "title": "SQL BETWEEN",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-between-1",
          "question": "What does the SQL BETWEEN operator do?",
          "options": [
            "It selects values within a given range, including the start and end values.",
            "It selects values outside a given range.",
            "It selects values within a given range but excludes the start and end values.",
            "It selects only values that match exactly one of two specified values."
          ],
          "answer": "It selects values within a given range, including the start and end values.",
          "explanation": "The SQL BETWEEN operator is used to filter the result set for values that fall within a specified range, including the boundaries."
        },
        {
          "id": "sql-between-2",
          "question": "Which of the following SQL queries correctly uses the BETWEEN operator to find products priced between $50 and $100?",
          "options": [
            "SELECT * FROM products WHERE price BETWEEN 50 AND 100;",
            "SELECT * FROM products WHERE price >= 50 AND price <= 100;",
            "SELECT * FROM products WHERE price IN (50, 100);",
            "SELECT * FROM products WHERE price = 50 OR price = 100;"
          ],
          "answer": "SELECT * FROM products WHERE price BETWEEN 50 AND 100;",
          "explanation": "The correct way to use BETWEEN is 'BETWEEN 50 AND 100', which includes all products with a price in this range, including $50 and $100."
        },
        {
          "id": "sql-between-3",
          "question": "Write a SQL query to find all employees who were hired between January 1, 2020, and December 31, 2023. Use the 'employees' table.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, hire_date DATE);",
            "INSERT INTO employees (employee_id, name, hire_date) VALUES (1, 'John', '2020-02-15'), (2, 'Jane', '2019-06-10'), (3, 'Emily', '2023-07-19');"
          ],
          "expectedResult": "SELECT * FROM employees WHERE hire_date BETWEEN '2020-01-01' AND '2023-12-31';",
          "explanation": "This query uses the BETWEEN operator to select employees who were hired within the specified date range, including both the start and end dates."
        },
        {
          "id": "sql-between-4",
          "question": "Write a SQL query to list all products whose prices are between $10 and $30, using the 'products' table.",
          "initialData": [
            "CREATE TABLE products (product_id INTEGER PRIMARY KEY, product_name TEXT, price DECIMAL);",
            "INSERT INTO products (product_id, product_name, price) VALUES (1, 'Keyboard', 25), (2, 'Mouse', 15), (3, 'Monitor', 75);"
          ],
          "expectedResult": "SELECT product_name, price FROM products WHERE price BETWEEN 10 AND 30;",
          "explanation": "The query selects product names and prices for all products that have a price between $10 and $30, including those priced exactly at $10 and $30."
        },
        {
          "id": "sql-between-5",
          "question": "Which SQL query would you use to find all customers whose age is between 18 and 35?",
          "options": [
            "SELECT * FROM customers WHERE age BETWEEN 18 AND 35;",
            "SELECT * FROM customers WHERE age > 18 AND age < 35;",
            "SELECT * FROM customers WHERE age IN (18, 35);",
            "SELECT * FROM customers WHERE age = 18 OR age = 35;"
          ],
          "answer": "SELECT * FROM customers WHERE age BETWEEN 18 AND 35;",
          "explanation": "The BETWEEN operator is used to find all customers within the age range of 18 to 35, including both ages."
        },
        {
          "id": "sql-between-6",
          "question": "Write a SQL query to find all orders placed between March 1, 2023, and May 31, 2023, using the 'orders' table.",
          "initialData": [
            "CREATE TABLE orders (order_id INTEGER PRIMARY KEY, order_date DATE, total_amount DECIMAL);",
            "INSERT INTO orders (order_id, order_date, total_amount) VALUES (1, '2023-03-15', 200), (2, '2023-05-05', 150), (3, '2023-06-10', 300);"
          ],
          "expectedResult": "SELECT * FROM orders WHERE order_date BETWEEN '2023-03-01' AND '2023-05-31';",
          "explanation": "This query uses the BETWEEN operator to retrieve orders that were placed between March 1 and May 31, 2023, including both dates."
        },
        {
          "id": "sql-between-7",
          "question": "Write a SQL query to find all students with test scores between 70 and 90 using the 'students' table.",
          "initialData": [
            "CREATE TABLE students (student_id INTEGER PRIMARY KEY, name TEXT, test_score INTEGER);",
            "INSERT INTO students (student_id, name, test_score) VALUES (1, 'Alice', 85), (2, 'Bob', 65), (3, 'Charlie', 90), (4, 'David', 95);"
          ],
          "expectedResult": "SELECT name, test_score FROM students WHERE test_score BETWEEN 70 AND 90;",
          "explanation": "This query uses the BETWEEN operator to find students whose test scores are between 70 and 90, inclusive."
        },
        {
          "id": "sql-between-8",
          "question": "Which of the following is true about the SQL BETWEEN operator?",
          "options": [
            "It is inclusive, meaning it includes the boundary values in the range.",
            "It excludes the boundary values in the range.",
            "It is used only with numeric values.",
            "It always returns NULL for any NULL values in the range."
          ],
          "answer": "It is inclusive, meaning it includes the boundary values in the range.",
          "explanation": "The BETWEEN operator is inclusive, meaning it includes both the start and end values in the specified range."
        }
      ]
    },
    {
      "id": "sql-in",
      "type": "topic",
      "title": "SQL IN Operator",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-in-1",
          "question": "What does the SQL IN operator do?",
          "options": [
            "It selects values that match any value in a given list.",
            "It selects values within a given range.",
            "It selects values outside of a given list.",
            "It selects values that match exactly one of two specified values."
          ],
          "answer": "It selects values that match any value in a given list.",
          "explanation": "The SQL IN operator is used to filter the result set by matching values in a list of values."
        },
        {
          "id": "sql-in-2",
          "question": "Which of the following SQL queries correctly uses the IN operator to find all products whose category is either 'Electronics', 'Furniture', or 'Toys'?",
          "options": [
            "SELECT * FROM products WHERE category IN ('Electronics', 'Furniture', 'Toys');",
            "SELECT * FROM products WHERE category = ('Electronics', 'Furniture', 'Toys');",
            "SELECT * FROM products WHERE category BETWEEN 'Electronics' AND 'Toys';",
            "SELECT * FROM products WHERE category LIKE ('Electronics', 'Furniture', 'Toys');"
          ],
          "answer": "SELECT * FROM products WHERE category IN ('Electronics', 'Furniture', 'Toys');",
          "explanation": "The IN operator allows you to match any value within a list, in this case, 'Electronics', 'Furniture', and 'Toys'."
        },
        {
          "id": "sql-in-3",
          "question": "Write a SQL query to find all students whose grades are either 'A', 'B', or 'C'. Use the 'students' table.",
          "initialData": [
            "CREATE TABLE students (student_id INTEGER PRIMARY KEY, name TEXT, grade TEXT);",
            "INSERT INTO students (student_id, name, grade) VALUES (1, 'Alice', 'A'), (2, 'Bob', 'B'), (3, 'Charlie', 'D');"
          ],
          "expectedResult": "SELECT * FROM students WHERE grade IN ('A', 'B', 'C');",
          "explanation": "The query uses the IN operator to filter students whose grades are 'A', 'B', or 'C', returning only those that match one of the values."
        },
        {
          "id": "sql-in-4",
          "question": "Write a SQL query to find all employees who are working in the 'HR' or 'Engineering' departments using the 'employees' table.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, department TEXT);",
            "INSERT INTO employees (employee_id, name, department) VALUES (1, 'John', 'HR'), (2, 'Jane', 'Engineering'), (3, 'Emily', 'Marketing');"
          ],
          "expectedResult": "SELECT * FROM employees WHERE department IN ('HR', 'Engineering');",
          "explanation": "This query uses the IN operator to filter employees who work in either the 'HR' or 'Engineering' departments."
        },
        {
          "id": "sql-in-5",
          "question": "Which SQL query would you use to find all orders where the total amount is either $100, $150, or $200?",
          "options": [
            "SELECT * FROM orders WHERE total_amount IN (100, 150, 200);",
            "SELECT * FROM orders WHERE total_amount BETWEEN 100 AND 200;",
            "SELECT * FROM orders WHERE total_amount LIKE (100, 150, 200);",
            "SELECT * FROM orders WHERE total_amount = 100 OR 150 OR 200;"
          ],
          "answer": "SELECT * FROM orders WHERE total_amount IN (100, 150, 200);",
          "explanation": "The IN operator allows you to match any of the values within the list, making it the correct choice for this query."
        },
        {
          "id": "sql-in-6",
          "question": "Write a SQL query to find all products where the supplier is either 'Supplier A' or 'Supplier B'. Use the 'products' table.",
          "initialData": [
            "CREATE TABLE products (product_id INTEGER PRIMARY KEY, product_name TEXT, supplier_name TEXT);",
            "INSERT INTO products (product_id, product_name, supplier_name) VALUES (1, 'Laptop', 'Supplier A'), (2, 'Mouse', 'Supplier B'), (3, 'Keyboard', 'Supplier C');"
          ],
          "expectedResult": "SELECT * FROM products WHERE supplier_name IN ('Supplier A', 'Supplier B');",
          "explanation": "This query filters products where the supplier is either 'Supplier A' or 'Supplier B', using the IN operator to match any value in the list."
        },
        {
          "id": "sql-in-7",
          "question": "Which of the following is true about the SQL IN operator?",
          "options": [
            "It allows matching values within a specified list of values.",
            "It is used to match values within a range.",
            "It excludes all values from the list provided.",
            "It only works with numeric values."
          ],
          "answer": "It allows matching values within a specified list of values.",
          "explanation": "The IN operator matches any value that exists in the provided list, making it useful for filtering specific values."
        },
        {
          "id": "sql-in-8",
          "question": "Write a SQL query to find all movies released in the years 2010, 2015, or 2020 using the 'movies' table.",
          "initialData": [
            "CREATE TABLE movies (movie_id INTEGER PRIMARY KEY, title TEXT, release_year INTEGER);",
            "INSERT INTO movies (movie_id, title, release_year) VALUES (1, 'Inception', 2010), (2, 'The Martian', 2015), (3, 'Tenet', 2020);"
          ],
          "expectedResult": "SELECT * FROM movies WHERE release_year IN (2010, 2015, 2020);",
          "explanation": "This query uses the IN operator to filter movies that were released in the years 2010, 2015, or 2020."
        }
      ]
    },
    {
      "id": "sql-union",
      "type": "topic",
      "title": "SQL UNION and UNION ALL",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-union-1",
          "question": "What is the difference between UNION and UNION ALL in SQL?",
          "options": [
            "UNION removes duplicate records, while UNION ALL includes all records, including duplicates.",
            "UNION returns all rows in both tables, while UNION ALL returns only unique rows.",
            "UNION performs an INNER JOIN, while UNION ALL performs a LEFT JOIN.",
            "UNION compares values, while UNION ALL compares column names."
          ],
          "answer": "UNION removes duplicate records, while UNION ALL includes all records, including duplicates.",
          "explanation": "UNION returns distinct rows by default, whereas UNION ALL returns all rows, including duplicates."
        },
        {
          "id": "sql-union-2",
          "question": "Which of the following SQL queries correctly combines the results of two SELECT statements while removing duplicate records?",
          "options": [
            "SELECT * FROM table1 UNION SELECT * FROM table2;",
            "SELECT * FROM table1 UNION ALL SELECT * FROM table2;",
            "SELECT * FROM table1 JOIN table2;",
            "SELECT * FROM table1 LEFT JOIN table2;"
          ],
          "answer": "SELECT * FROM table1 UNION SELECT * FROM table2;",
          "explanation": "The UNION operator combines the results of two queries and removes duplicate rows by default."
        },
        {
          "id": "sql-union-3",
          "question": "Write a SQL query to combine all records from the 'customers' and 'suppliers' tables, removing any duplicates. Select the 'name' and 'location' columns from both tables.",
          "initialData": [
            "CREATE TABLE customers (customer_id INTEGER PRIMARY KEY, name TEXT, location TEXT);",
            "CREATE TABLE suppliers (supplier_id INTEGER PRIMARY KEY, name TEXT, location TEXT);",
            "INSERT INTO customers (customer_id, name, location) VALUES (1, 'Alice', 'New York'), (2, 'Bob', 'Los Angeles');",
            "INSERT INTO suppliers (supplier_id, name, location) VALUES (1, 'TechCorp', 'New York'), (2, 'Alice', 'New York');"
          ],
          "expectedResult": "SELECT name, location FROM customers UNION SELECT name, location FROM suppliers;",
          "explanation": "This query combines the records from both 'customers' and 'suppliers' tables and removes duplicate records such as 'Alice' from New York, who appears in both tables."
        },
        {
          "id": "sql-union-4",
          "question": "Write a SQL query to combine all products from the 'electronics' and 'furniture' tables. Include duplicates. Select the 'product_name' and 'price' columns from both tables.",
          "initialData": [
            "CREATE TABLE electronics (product_id INTEGER PRIMARY KEY, product_name TEXT, price DECIMAL);",
            "CREATE TABLE furniture (product_id INTEGER PRIMARY KEY, product_name TEXT, price DECIMAL);",
            "INSERT INTO electronics (product_id, product_name, price) VALUES (1, 'Laptop', 1000), (2, 'Mouse', 50);",
            "INSERT INTO furniture (product_id, product_name, price) VALUES (1, 'Table', 200), (2, 'Laptop', 1000);"
          ],
          "expectedResult": "SELECT product_name, price FROM electronics UNION ALL SELECT product_name, price FROM furniture;",
          "explanation": "The query combines all products from both tables, including duplicate records such as 'Laptop', which is present in both tables, by using UNION ALL to include all rows."
        },
        {
          "id": "sql-union-5",
          "question": "Which SQL operator should you use to combine the results of two queries while keeping duplicate records?",
          "options": [
            "UNION ALL",
            "UNION",
            "LEFT JOIN",
            "RIGHT JOIN"
          ],
          "answer": "UNION ALL",
          "explanation": "UNION ALL combines the results of two queries and includes all records, even if they are duplicates."
        },
        {
          "id": "sql-union-6",
          "question": "What is the key difference between UNION and a LEFT JOIN?",
          "options": [
            "UNION combines the results of two queries, while LEFT JOIN combines columns from two tables based on a matching condition.",
            "UNION removes NULL values, while LEFT JOIN retains them.",
            "UNION compares only columns with identical data types, while LEFT JOIN compares all columns.",
            "UNION always returns more rows than a LEFT JOIN."
          ],
          "answer": "UNION combines the results of two queries, while LEFT JOIN combines columns from two tables based on a matching condition.",
          "explanation": "UNION stacks the results of two queries together, while a LEFT JOIN combines data from two tables based on a key, filling in NULLs for missing matches."
        },
        {
          "id": "sql-union-7",
          "question": "Write a SQL query to combine the results of two SELECT statements that retrieve the names of employees from the 'hr_employees' table and 'sales_employees' table. Ensure there are no duplicate names in the result.",
          "initialData": [
            "CREATE TABLE hr_employees (employee_id INTEGER PRIMARY KEY, name TEXT);",
            "CREATE TABLE sales_employees (employee_id INTEGER PRIMARY KEY, name TEXT);",
            "INSERT INTO hr_employees (employee_id, name) VALUES (1, 'John'), (2, 'Jane');",
            "INSERT INTO sales_employees (employee_id, name) VALUES (1, 'Alice'), (2, 'John');"
          ],
          "expectedResult": "SELECT name FROM hr_employees UNION SELECT name FROM sales_employees;",
          "explanation": "This query combines the employee names from both tables and removes duplicates, such as 'John', who appears in both tables."
        },
        {
          "id": "sql-union-8",
          "question": "Which of the following SQL statements combines the result of two queries and includes all records, including NULLs from the right table where matches are missing?",
          "options": [
            "SELECT * FROM table1 LEFT JOIN table2;",
            "SELECT * FROM table1 UNION SELECT * FROM table2;",
            "SELECT * FROM table1 UNION ALL SELECT * FROM table2;",
            "SELECT * FROM table1 RIGHT JOIN table2;"
          ],
          "answer": "SELECT * FROM table1 RIGHT JOIN table2;",
          "explanation": "A RIGHT JOIN includes all records from the right table and matches them with records from the left table, including NULLs where there is no match."
        },
        {
          "id": "sql-union-9",
          "question": "Write a SQL query to combine all departments from the 'hr_departments' and 'sales_departments' tables, even if they are duplicates.",
          "initialData": [
            "CREATE TABLE hr_departments (dept_id INTEGER PRIMARY KEY, dept_name TEXT);",
            "CREATE TABLE sales_departments (dept_id INTEGER PRIMARY KEY, dept_name TEXT);",
            "INSERT INTO hr_departments (dept_id, dept_name) VALUES (1, 'HR'), (2, 'Recruiting');",
            "INSERT INTO sales_departments (dept_id, dept_name) VALUES (1, 'HR'), (2, 'Sales');"
          ],
          "expectedResult": "SELECT dept_name FROM hr_departments UNION ALL SELECT dept_name FROM sales_departments;",
          "explanation": "This query combines all departments from both tables, including duplicates like 'HR', by using UNION ALL to retain all rows."
        }
      ]
    },
    {
      "id": "sql-order-by",
      "type": "topic",
      "title": "SQL ORDER BY with Edge Cases",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "sql-order-by-1",
          "question": "What is the default behavior for sorting NULL values when using the ORDER BY clause in ascending order?",
          "options": [
            "NULL values appear first.",
            "NULL values appear last.",
            "NULL values are excluded from the result.",
            "SQL raises an error when sorting NULL values."
          ],
          "answer": "NULL values appear first.",
          "explanation": "In most databases, when sorting in ascending order (ASC), NULL values appear first by default."
        },
        {
          "id": "sql-order-by-2",
          "question": "Which of the following SQL queries correctly orders results by price in descending order, placing NULL values last?",
          "options": [
            "SELECT * FROM products ORDER BY price DESC NULLS LAST;",
            "SELECT * FROM products ORDER BY price NULLS LAST DESC;",
            "SELECT * FROM products ORDER BY price DESC WHERE price IS NOT NULL;",
            "SELECT * FROM products ORDER BY price DESC EXCLUDE NULLS;"
          ],
          "answer": "SELECT * FROM products ORDER BY price DESC NULLS LAST;",
          "explanation": "The 'NULLS LAST' clause ensures that NULL values are placed at the end of the result set, even when ordering in descending order."
        },
        {
          "id": "sql-order-by-3",
          "question": "Write a SQL query to select all employees and order them by hire_date in ascending order, placing NULL hire_dates last. Use the 'employees' table.",
          "initialData": [
            "CREATE TABLE employees (employee_id INTEGER PRIMARY KEY, name TEXT, hire_date DATE);",
            "INSERT INTO employees (employee_id, name, hire_date) VALUES (1, 'John', '2023-01-15'), (2, 'Jane', NULL), (3, 'Emily', '2022-06-10');"
          ],
          "expectedResult": "SELECT * FROM employees ORDER BY hire_date ASC NULLS LAST;",
          "explanation": "The query orders employees by hire_date in ascending order, placing rows with NULL hire_dates last using the 'NULLS LAST' clause."
        },
        {
          "id": "sql-order-by-4",
          "question": "Write a SQL query to order products by price in ascending order. Products with NULL prices should appear first. Use the 'products' table.",
          "initialData": [
            "CREATE TABLE products (product_id INTEGER PRIMARY KEY, product_name TEXT, price DECIMAL);",
            "INSERT INTO products (product_id, product_name, price) VALUES (1, 'Laptop', 1000), (2, 'Mouse', NULL), (3, 'Keyboard', 75);"
          ],
          "expectedResult": "SELECT * FROM products ORDER BY price ASC NULLS FIRST;",
          "explanation": "The query orders products by price in ascending order, but it places rows with NULL prices first using the 'NULLS FIRST' clause."
        },
        {
          "id": "sql-order-by-5",
          "question": "Which SQL statement orders employees by salary in descending order, placing NULL values first?",
          "options": [
            "SELECT * FROM employees ORDER BY salary DESC NULLS FIRST;",
            "SELECT * FROM employees ORDER BY salary NULLS FIRST DESC;",
            "SELECT * FROM employees ORDER BY salary DESC WHERE salary IS NOT NULL;",
            "SELECT * FROM employees ORDER BY salary DESC EXCLUDE NULLS;"
          ],
          "answer": "SELECT * FROM employees ORDER BY salary DESC NULLS FIRST;",
          "explanation": "The 'NULLS FIRST' clause ensures that NULL values appear at the top of the result set, even when sorting in descending order."
        },
        {
          "id": "sql-order-by-6",
          "question": "Write a SQL query to order students by test_score in descending order, placing NULL scores first. Use the 'students' table.",
          "initialData": [
            "CREATE TABLE students (student_id INTEGER PRIMARY KEY, name TEXT, test_score INTEGER);",
            "INSERT INTO students (student_id, name, test_score) VALUES (1, 'Alice', 85), (2, 'Bob', NULL), (3, 'Charlie', 90);"
          ],
          "expectedResult": "SELECT * FROM students ORDER BY test_score DESC NULLS FIRST;",
          "explanation": "This query orders students by test_score in descending order and places rows with NULL test scores first using 'NULLS FIRST'."
        },
        {
          "id": "sql-order-by-7",
          "question": "Which of the following describes how the ORDER BY clause sorts NULL values in SQL by default?",
          "options": [
            "NULL values are placed first in ascending order and last in descending order.",
            "NULL values are placed last in both ascending and descending order.",
            "NULL values are always excluded from the result set.",
            "SQL raises an error if NULL values are included in an ORDER BY clause."
          ],
          "answer": "NULL values are placed first in ascending order and last in descending order.",
          "explanation": "By default, in most databases, NULL values appear first when sorting in ascending order and last when sorting in descending order."
        },
        {
          "id": "sql-order-by-8",
          "question": "Write a SQL query to retrieve all movies, ordered by release_year in ascending order, with NULL values placed last. Use the 'movies' table.",
          "initialData": [
            "CREATE TABLE movies (movie_id INTEGER PRIMARY KEY, title TEXT, release_year INTEGER);",
            "INSERT INTO movies (movie_id, title, release_year) VALUES (1, 'Inception', 2010), (2, 'The Martian', NULL), (3, 'Tenet', 2020);"
          ],
          "expectedResult": "SELECT * FROM movies ORDER BY release_year ASC NULLS LAST;",
          "explanation": "The query orders movies by release_year in ascending order and places rows with NULL release_year values at the bottom using the 'NULLS LAST' clause."
        }
      ]
    }
  ]
}
